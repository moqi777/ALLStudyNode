# Vue3

## 1.前端环境搭建

#### 1.1 安装和配置vscode

- 下载群里vscode.exe 安装包 双击运行
- 设置 --> setting

`修改字体大小`

![修改字体大小](https://s2.loli.net/2024/08/20/5UJv2IlcCQuhmEO.png)

`修改主题`

![修改主题](https://s2.loli.net/2024/08/20/yeOYRqISHh5pisP.png)

`修改终端字体大小`

![修改终端字体大小](https://s2.loli.net/2024/08/20/6ro3VjDku9b2fZQ.png)

- 安装Vue3插件(之前版本volar被弃用) 安装新版本，否则使用vue3的语法会出现错误

![43b0e30bb6154e17803ed8abf9f1153d](https://s2.loli.net/2024/08/20/ZzJ1rjuKNW6Ds5R.png)

#### 1.2 vscode快速生成vue3模版

File(文件) -> Preferences(首选项) -> Configure Snippets(配置代码片段) -> 弹出输入框搜索vue(或者vue json)进入 -> 弹出窗口将下面json替换进去就可以

使用：在新建的vue文件 输入vue3 回车就可以生成模版

```json
{
"Print to console": {
"prefix": "vue3", //vue文件输入代码前缀
"body": [ //主体自动生成的代码格式
"<template>\n",
"</template>\n",
"<script setup>",
"import {ref} from \"vue\"",
"</script>\n",
"<style scoped>\n</style>",
"$2"
],
"description": "Log output to console"
}
}
```

#### 1.3 安装和配置node.js

node.js类似于java的jdk 是vue项目的运行环境 而且版本也很重要，如果是vue3 最低支持node14以上版本，具体看`node安装使用笔记.md`

#### 1.4 npm 和 cnpm

npm是node官方提供包管理器 cnpm是中国版的npm，是淘宝定制的命令行 用于替代npm 如果网络原因导致无法使用 推荐使用cnpm

- 安装方式：通过cmd，注意管理员身份运行

```
npm install -g cnpm --registry=https://registry.npmmirror.com/

安装成功：cnpm -v
```

#### 1.5 安装vue脚手架

vue脚手架 是用于快速构建vue项目的 类似于之前使用的maven，安装过程比较繁琐，可能会失败很多次，多装几次就好了

- 安装命令，注意管理员身份运行

```
cnpm install -g @vue/cli
测试：vue -V
```

#### 1.6 设置镜像地址

设置npm和cnpm地址都设置成淘宝镜像地址

```
npm config set registry https://registry.npmmirror.com/
cnpm config set registry https://registry.npmmirror.com/
```

## 2. Vue如何创建项目

如果一直创建项目失败可以尝试右键桌面vcCode图标 -> 属性 -> 兼容性 -> 以管理员身份运行此程序

- crtl+` 打开终端
- 输入命令创建项目：`vue create 项目名(必须小写)`
- 选择vue项目模版格式

```
  Default ([Vue 3] babel, eslint)		->vue3模版只带两个插件
  Default ([Vue 2] babel, eslint)       ->vue2模版只带了两个插件                   > Manually select features 			  -> 推荐手动选择插件
```

- 选择项目需要支持的插件，可以根据用户需要自由组合，使用上下箭头可以切换，`空格选中`，`回车确认`

```
>(*) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 ( ) Router
 ( ) Vuex
 ( ) CSS Pre-processors
 (*) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing
```

```
Babel：一个js编译器转码器 可以将ES6转换成ES5代码，主要用于向下兼容，必加项
TypeScript：底层就是对于js做了一个封装，相当于一种面向对象的js，简称ts，运行时也会转换成js		后期必导，如果选择了会有两个子菜单... 
	Use class-style component syntax? (y/N) 是否使用类风格装饰器(y)
	Use Babel alongside TypeScript  Babel和Ts是否一起使用(y)
web App：属于web应用程序，必加项
Router：vue路由，通过请求链接到具体哪个vue组件的(跳转)，后期必导
	Use history mode for router?  配置路由历史模式 选N
Vuex：vue的状态管理模式，可以保存一些vue中的对象
CSS：css预处理器，一般不导
Linter / Formatter：代码风格检查和格式化，用于检查代码是否符合规范的，不导慎用
Unit Testing：单元测试插件，类似于Java的junit
E2E Testing：(end to end) 端到端的测试
```

- 配置 配置文件放在哪里 是默认位置还是放在package.json中，推荐使用默认

```
> In dedicated config files		-> 使用默认位置
  In package.json				-> 放入package.json
```

- 是否保存历史配置，可以保存上一次创建vue插件配置，可以让我们更加快捷创建项目，后期可以使用，当前选N。保存的模版在 `C:\Users\86134\.vuerc`中可以查看，删除模版也在这里

```
Save this as a preset for future projects? (y/N)
```

- 项目创建成功后

```
cd 项目名   		-> 进入项目
npm run serve	  ->启动项目
```

你也可以使用`vue ui`命令打开图形化界面管理vue项目

## 3. 什么是Vue

vue是一个前端框架，免除一些原生的javascript中的繁琐的dom操作，是基于MVVM(Model-View-ViewMode)思想，用于实现数据双向绑定，使开发者只关注于数据即可

- MVVM思想：可以用于实现数据双向绑定，就是模型的数据(Mode) 发生了改变 页面展示的数据(View)也会改变，反之如果展示的数据发生修改了 模型的数据也会发生改变。VM(ViewModel)就是用于实现Model和View之间数据双向绑定 通常ViewModel是通过js实现的(Vue对象)

==vue2是选项式API，默认就是响应式数据。vue3是组合式API，默认是引用式数据，所以需要通过`ref`改为响应式数据==

#### 3.1 项目目录结构

![image-20240821144554938](https://s2.loli.net/2024/08/21/tSJVgm7LTiqhaAC.png)

- node_modules：运行vue项目需要第三方组件或者插件 类似于maven导入的依赖(jar) 如果删掉了 只需要`vue install`重新安装回来
- public：vue项目提供默认图标首页 一般vue项目写完后进行打包时 会默认存储在这个位置 会把vue项目的组件转换成css/html，输入命令`vue build`打包，/public访问资源
- src：重点目录
  - asses：存储静态资源的位置 css img...，../assess访问资源
  - components：存放vue组件的目录，创建所有的vue页面都放在该目录下，但是以后添加了路由router 就放在router包
  - App.vue：Vue核心组件 所有组件都必须经过App组件 否则失效，因为它是Vue项目的默认首页
  - 类似于java的main方法 程序的入口
  - registerServiceWorker.js：存储一些监听的 不重要
- package.json：等价于之前maven项目中的pom.xml，vue项目安装所有插件和第三方组件都可以在这里查看
- vue.config.js：等价于springboot中的application.properties vue项目的唯一配置文件   ==注：配置文件只要修改 必须重启Vue项目==

## 4. Vue基础语法

```vue
<!--表示编写html内容-->
<template></template>

<!--表示编写vue业务逻辑的，通过js基础编写的 vue2语法-->
<script>
    //导出当前默认组件
	export default{}
</script>

<!--属于vue3语法 可以不用写export data() return...-->
<script setup></script>

<!--编写css-->
<!-- scoped 是为了设置样式不影响其他组件 -->
<style scoped></style>
```

#### 4.1 vue声明变量的方式有哪些 ---面试题

- var：通常用于定义全局变量，允许重复声明
- let：ES6新增的，用来替代var的，只能作用于局部区域，不能重复声明
- const：ES6新增的 用来声明常量的(最常用的) 只能作用于局部区域 不能重复声明

```vue
<script setup>
    import {ref} from 'vue'
    const user=ref();
    //这样user对象地址不能改 但是对象里面的属性是可以修改的
</script>
```

#### 4.2 vue基本指令

指定：就是html标签里面添加带有v-前缀的特殊属性，不同指令具有不同的函数，而vue是通过这些指令来实现页面动态的效果 

| 指令                    | 作用                                                |
| ----------------------- | --------------------------------------------------- |
| v-bind（:）             | 为html标签绑定属性值 比如设置href css样式，单项绑定 |
| v-model                 | 为表单元素创建双向数据绑定的，双向绑定              |
| v-if  v-else=if  v-else | 条件性渲染元素                                      |
| v-show                  | 条件性渲染元素                                      |
| v-for                   | 列表渲染 遍历下面定义集合和数组变量的               |
| v-on（@）               | 为html标签绑定事件                                  |

==vue2 v-if 和 v-for同时使用优先级 v-for > v-if
vue3 v-if 和 v-for 同时使用优先级 v-for < v-if
vue3 v-show 和 v-for 同时使用优先级 v-for > v-show==

- v-binf指令和v-model指令 

`v-model.lazy`：懒加载，输入结束后才会同步
`v-model.trim`：去除前后空格

```vue
<template>
    <!-- v-bind 用于绑定属性值
        将下面vue创建的变量 给标签属性值使用 -->
     <a v-bind:href="url">链接1</a>
     <!-- v-bind可以省略 -->
     <a :href="url">链接2</a>
     <!-- 借助于双向绑定修改url的值 -->
      地址：<input v-model="url">
</template>

<script setup>
import {ref} from 'vue'
const url = ref('http://www.baidu.com')
</script>
```

- v-if指令和v-show指令

区别：---面试题

​				if底层不满足就不会去渲染标签 所以标签是不存在的
​        	  show底层通过display是否切换none来显示隐藏的  标签都是存在的 但是有的隐藏了看不到

```vue
<template>
    <div v-show="status==1">show启用</div>
    <div v-show="status==0">show禁用</div>
    <div v-show="status==2">show未验证</div>

    <div v-if="status==1">启用</div>
    <div v-else-if="status==0">禁用</div>
    <div v-else-if="status==2">未验证</div>
    <div v-else>冻结</div>
    <input v-model="status">
</template>

<script setup>
import {ref} from 'vue'
const status = ref(1)
</script>
```

- v-for指令

```vue
<!--语法规则，集合和数组需要在js中定义好变量-->
<标签 v-for="临时变量 in 集合或数组">
	{{临时变量}}    
</标签>
<!--语法规则2：如果页面需要变量的数据的索引-->
<标签 v-for="(临时变量,索引变量) in 集合或数组">
	{{索引变量+1}}    {{临时变量}}
</标签>
```

```vue
<template>
    <table>
        <tr>
            <th>序号</th>
            <th>编号</th>
            <th>地址</th>
        </tr>
        <tr v-for="va in address">
            <td></td>
            <td>{{ va.id }}</td>
            <td>{{ va.addrname }}</td>
        </tr>
        <hr>
        <tr v-for="(va,i) in address">
            <td>{{ i }}</td>
            <td>{{ va.id }}</td>
            <td>{{ va.addrname }}</td>
        </tr>
    </table>
</template>

<script setup>
import {ref} from 'vue'
const address = ref([
    {id:8,addrname:'南昌'},
    {id:7,addrname:'北京'},
    {id:10,addrname:'上海'},
    {id:12,addrname:'济南'}
])
</script>
```

- v-on指令

```vue
<template>
    <div>
        <input type="button" value="确认" v-on:click="show()"/>
        <!-- 但是以后编写 v-on: -> @ -->
        <input type="button" value="确认@" @click="show()"/>
    </div>
</template>

<script setup>
import {ref} from 'vue'
const show = ()=>{
    console.log("hello");
}
</script>
```

## 5. 组件基础

Vue是基于组件开发的，我们创建每一个*.vue文件 它是一种特殊的文件格式，在vue中称这种文件叫做Vue组件(html 样式css 业务逻辑js)。一个组件的组成部分在`4.Vue基础语法`章节中中写了

#### 5.1 加载组件步骤

- 引入组件：javascript标签内

```js
import 组件名(可以自定义) from "./compontens/XXX.vue"
```

- 挂载组件：javascript标签内==如果使用vue3.2 setup语法糖 可以省略挂载组件==

`vue2版本`

```js
export default{
	components:{
        组件名1,
        组件名2,
        ...
	}	
}
```

`vue3版本`

```js
<script setup>
import { defineComponent } from "vue"
//vue3.2需要使用defineComponent()
defineComponent({
    components:{
        组件名1,
        组件名2,
        ...
    }
})
</script>
```

- 显示组件：template标签内编写

```html
<组件名/>
```

#### 5.2 组件的交互(父->子) ---面试题

组件和组件之间如果没有任何关系 就没有意义了 他们之间是可以进行交互的，比如：a组件的数据 交给b组件使用 通过prop来组件交互

- 老版本传递方式

  - 父组件

  ```vue
  <template>
      <h3>父组件</h3>
      <!-- vue老版本 通过:属性名(任意) 属性值就是要传递的数据(可以传递任意数据) -->
      <!-- 就是 v-bind 绑定属性名 只不过属性是任意编写 -->
      <two :myAge :name="myName" :user="myUser" :list="myList"/>
  </template>
  
  <!-- vue老版本 -->
  <script>
  import two from './Child.vue'
  export default{
      components:{
          two
      },
      data(){
          return{
              myAge:20,
              myName:'张三',
              myUser:{id:1,sex:'男',class:'sc240601'},
              myList:['java','mysql','js','vue']
          }
      }
  }
  
  </script>
  ```

  - 子组件

  ```vue
  <template>
      <h3>子组件</h3>
      <h3>年龄：{{ myAge }}</h3>
      <h3>姓名：{{ name }}</h3>
      <h3>对象：{{ user.id }}  {{ user.sex }}  {{ user.class }}</h3>
      <h3>集合数字：
          <span v-for="s in list">{{ s+" " }}</span>
      </h3>
  </template>
  
  <script>
      export default{
          // 通过props来接收父组件传递的数据
          //age就是父组件传递过来的属性名(自定义的)
          props:{
              myAge:{type:Number,default:0},
              name:{type:String,default:""},
              user:{type:Object,default:null},
              list:{type:Array,default:[]}
          }
      }
  </script>
  ```

- 新版本传递方式

  - 父组件

  ```vue
  <template>
      <h3>父组件</h3>
      <!-- 3.显示子组件 -->
      <!-- vue老版本 新版本都类似于 通过:属性名(任意) 属性值就是要传递的数据(可以传递任意数据) -->
      <!-- 就是 v-bind 绑定属性名 只不过属性是任意编写 -->
      <two :myAge :name="myName" :user="myUser" :list="myList"/>
  </template>
  
  <script setup>
  import { defineComponent, ref } from "vue"
  //1.引入组件
  import two from './Child.vue'
  //2.挂载组件 vue3.2需要使用defineComponent()
  defineComponent({
      components:{
          two
      }
  })
  const myAge = ref(18)
  const myName = ref("李四")
  const myUser = ref({id:1,sex:'男',class:'sc240601'})
  const myList = ref(['java','mysql','js','vue'])
  </script>
  ```

  - 子组件

  ```vue
  <template>
      <h3>子组件</h3>
      <h3>年龄：{{ myAge }}</h3>
      <h3>姓名：{{ name }}</h3>
      <h3>对象：{{ user.id }}  {{ user.sex }}  {{ user.class }}</h3>
      <h3>集合数字：
          <span v-for="s in list">{{ s+" " }}</span>
      </h3>
  </template>
  
  <script setup>
  import {} from "vue"
  //vue3.2 通过defineProps来接收父组件的值
  defineProps({
      myAge:{type:Number,default:0},
      name:{type:String,default:""},
      user:{type:Object,default:null},
      list:{type:Array,default:[]}
  })
  </script>
  ```

  

#### 5.3 组件的交互(子->父) ---面试题

子组件想传值给父组件借助于自定义事件，如果是vue之前的版本 借助于this.$emit(自定义事件，数据) 如果是新版的方式 通过导入defineEmits() 创建一个触发器绑定自定义事件

- 老板实现方式

`父组件`

```vue
<template>
    <h3>父组件</h3>
    <h3>父组件接收的数据：{{ result }}</h3>
    <two @childSend="getChildSend"/>
</template>

<script>
import two from './Child.vue'
export default{
    components:{
        two
    },
    data(){
        return{
            result:""
        }
    },
    methods:{
        // 方法参数：就是子组件传递来的数据
        getChildSend:function(result){
            this.result=result
        }
    }
}
</script>
```

`子组件`

```vue
<template>
    <h4><button @click="send">发送数据</button></h4>
    <h4><input v-model="msg"></h4>
</template>

<script>
    export default{
        data(){
            return{
                msg:""
            }
        },
        methods:{
            send:function(){
                //this.$emit用于向父组件传递数据
                //参数1：自定义事件名；参数2：传递的数据(任意类型)
                this.$emit("childSend",this.msg)
            }
        }
    }
</script>
```

- 新版实现方式

`父组件`

```vue
<template>
    <h3>父组件</h3>
    <h3>父组件接收的数据：{{ result }}</h3>
    <two @childSend="getChildSend"/>
</template>

<script setup>
import { defineComponent, ref } from "vue"
//1.引入组件
import two from './Child.vue'
//2.挂载组件 vue3.2需要使用defineComponent()
defineComponent({
    components:{
        two
    }
})
const result = ref();
const getChildSend = (res)=>{
    result.value=res
}
</script>
```

`子组件`

```vue
<template>
    <h4><button @click="send">发送数据</button></h4>
    <h4><input v-model="msg"></h4>
</template>

<script setup>
import { ref,defineEmits } from "vue"
//defineEmits() 返回一个触发器 用于触发自定义事件
//childSend 自定义方法名，可以多个
const emit = defineEmits(['childSend'])
const msg = ref();
const send = ()=>{
    //绑定值
    emit('childSend',msg.value)
}
</script>
```

==注：上面几种传递方式前提组件具有父子关系，如果没有父子关系借助于路由来传递数据==

==注：箭头函数中不要用this会出错==

## 6. 组件生命周期 ---面试题

组件在被创建或者使用时都会经过不同的阶段 比如：设置数据监听，实例挂载到组件中 ... 每经过一个阶段 都会运行一些生命周期函数 用于给用户实现不同阶段完成不同的业务逻辑

声明周期一共有八个阶段：每触发一个阶段都会自动运行一个生命周期的函数，这些生命周期函数 也叫钩子函数

| 状态(钩子函数) | 阶段周期                  |
| -------------- | ------------------------- |
| beforeCreate   | 创建前阶段                |
| created        | 创建后                    |
| beforeMount    | 载入前 渲染前             |
| mounted        | 挂载完成 渲染后           |
| beforeUpdate   | 更新前 页面数据发生了变化 |
| updated        | 更新后 页面数据发生了变化 |
| beforeDestory  | 销毁前                    |
| destoryed      | 销毁后                    |

![ffaf9787c468ae94a307b520c4ec8f17](https://s2.loli.net/2024/08/22/cPEXdSKRZn6OFAh.png)

#### 6.1 代码实现

`老版代码实现`

```vue
<template>
<input v-model="msg">
</template>

<!-- 老版钩子函数 和 methods 是同级的-->
<script>
export default{
    data(){
        return{
            msg:"呵呵"
        }
    },
    //函数的位置
    methods:{

    },
    // 钩子函数：随着生命周期的变化自动触发
    //页面刚刚加载，会根据不同生命周期阶段执行下面4个函数
    beforeCreate:()=>{
        console.log("创建前");
    },
    created(){
        console.log("创建后，创建一些vue核心对象");
    },
    beforeMount:function(){
        console.log("挂载前");
    },
    //最常用的 经常需要在这里加载后端数据
    mounted(){
        console.log("挂载后，页面已经渲染完毕，可以在前端看到效果了");
    },
    //当任意数据发生改变 会执行下面的两个函数
    beforeUpdate(){
        console.log("更新前");
    },
    updated(){
        console.log("更新后");
    },
    //当组件销毁 看不到效果的 会自动执行下面两个函数
    beforeDestroy(){
        console.log("卸载前");
    },
    destroyed(){
        console.log("卸载后");
    }
}
</script>
```

`新版代码实现`

```vue
<template>
<input v-model="msg">
</template>
<!-- 新版钩子函数
     跟旧版相比 新版的vue方式beforeCreate和created 已经被调用了
     所以这两个函数在使用时是可以忽略的
     需要导入对应的函数名(on钩子函数) 通过import
     而且每种钩子函数可以编写多个 -->
<script setup>
const msg = ref()
import {onMounted, onUpdated, ref} from "vue"
onMounted(()=>{
    console.log("挂载后");
})
onUpdated(()=>{
    console.log("更新后");
    
})
</script>
```

## 7. Vue引入第三方

第三方不属于vue，是其他人写好可以基于vue来实现很多常用功能，不需要我们自己再单独编写，而我们只需要学习如何引入这些成熟第三方即可

比如：ElementPlus(前端后台页面 面向pc端)、Vant(前端前台页面 面向移动端)、swiper(免费触摸滑动 轮播组件 面向pc端 移动端 平板端都可以) ...

#### 7.1 vue引入swiper第三方

[官网](https://www.swiper.com.cn/)

- vue项目中(项目根目录下)安装swiper

```
-- 安装最新版swiper
cnpm install --save swiper
-- 可以指定版本安装
cnpm install --save swiper@10.2.0
```

- 在组件中导入swiper，类似于之前学习的组件引入

`案例`

```vue
<template>
    <!-- 
        modules：类似于v-model 做双向绑定的 只不过它是绑定很多变量
        需要在下面定义好数组的变量
        navigation：使用上一页下一页
        pagination：开启页码指示器
        autoplay：自动播放
    -->
    <Swiper 
    :modules="modules"
    navigation
    :pagination="{clickable:true}"
    :autoplay="{delay:5000}"
    mousewheel
    >
        <SwiperSlide>
            <img src="../assets/logo.png"/>
        </SwiperSlide>
        <SwiperSlide>
            <img src="../assets/logo.png"/>
        </SwiperSlide>
        <SwiperSlide>
            <img src="../assets/logo.png"/>
        </SwiperSlide>
    </Swiper>
</template>
<!-- 如果使用vue3.2 setup语法糖 可以省略挂载组件 -->
<script setup>
import {Swiper,SwiperSlide} from "swiper/vue";
import {Autoplay,Navigation,Pagination,Mousewheel} from 'swiper/modules'
import 'swiper/css';
import 'swiper/css/navigation'
import 'swiper/css/pagination'
import 'swiper/css/mousewheel'
const modules=[Autoplay,Navigation,Pagination,Mousewheel]
</script>
```

## 8. Vue发送异步请求

#### 8.1 发送异步请求

- 原生js实现的，步骤比较复杂 不推荐
- jQuery封装好的方法 $.post() $.get() $.ajax()，但是需要手动控制请求和响应的数据格式 不推荐
- 通过axios发生异步请求 底层就是对jQuery的ajax进一步的封装，非常适合前后端分离的项目 它默认的传输格式就是Json 推荐使用

#### 8.2 axios安装和使用

- 安装命令

```
cnpm install --save axios
```

- 引入axios
  - 通过`import axios from 'axios' ` 这样使用的话缺点 每个组件都需要引入 比较多 繁琐 也容易忘导入
  - 全局导入：在vue项目入口(main.js) 添加一段配置 这样以后每个组件都无需导入axios

`main.js`

```js
import axios from 'axios'

const app = createApp(App)
//全局引入axios 这样定义好了后 其他组件就可以通过这个任意名称 发送异步请求
//就是在全局配置中添加了 axios别名
app.config.globalProperties.aaa=axios
app.mount('#app')
```

`vue组件中新版使用案例`

```vue
<template>
    <p>账号：<input v-model="user.account"></p>
    <p>密码：<input v-model="user.password"></p>
    <p>手机：<input v-model="user.phone"></p>
    <button @click="add">新增</button>
</template>

<script setup>
import {ref,getCurrentInstance} from "vue"
// 类似于老版本的this获取当前的实例 {proxy} 是固定返回的 要求不能改名字 需要加大括号
// 老版直接this.aaa.post ...
const {proxy} = getCurrentInstance()
const user=ref({})
let add = ()=>{
    proxy.aaa.post("http://localhost:8082/add",user.value).then(res=>{
        console.log(res.data);
    })
}
</script>
```

#### 8.3 请求的封装 ---重点

虽然使用了单次导入axios和全局导入axios 但是两种方式各有优缺点，全局导入缺点 没有对请求的安全做限制 而且 发送请求的时候也会有很多相同的部分

```
http://localhost:9999/add
http://localhost:9999/sel
http://localhost:9999	就属于相同的部分
```

- 创建一个包`src/util`	创建一个`request.js`(或者`http.js`) 

`request.js`

```js
//将axios对象进行封装 提高安全性
//1.导入axios
import axios from "axios";

//2.创建错误映射    status:状态码  info:错误信息
const errorHandler = (status,info)=>{
    switch(status){
        case 400:console.log("客户端参数有误");break;
        case 403:console.log("无访问权限");break;
        case 404:console.log("资源不存在/地址错误");break;
        case 500:console.log(info);break;
        default:console.log(info);
    }
}

//3.通过axios创建请求实例
const instance = axios.create({
    //控制超时时间 单位毫秒
    timeout:5000
})

//4.通过请求实例配置请求拦截器(成功的函数,失败的函数)
instance.interceptors.request.use(
    config=>{
        if(config.method == "post"){
            //处理所有的post请求 看公司要求
        }else if(config.method == "get"){
            //处理所有的get请求
        }
        //... 可以写很多个
        return config;
    },
    error=>{
        //返回错误信息
        return Promise.reject(error)
    }
)
//5.通过请求实例配置响应拦截器(响应成功的函数,响应失败的数据)
instance.interceptors.response.use(
    response=>{
        //根据状态码是否是200来控制是否返回正确或失败信息
        return response.status==200?Promise.resolve(response):Promise.reject(response)
    },
    error=>{
        //定义响应变量 常量 不能改
        const {response} = error
        //调用上面的错误映射传入状态码和错误信息
        errorHandler(response.status,response.info)
    }
)

//6.导出请求实例
export default instance;
```

- 创建一个包 api包（一般存放的是发送网络请求，文件可能会有很多），比如：base.js（可以处理通用地址)	index.js  user.js   bbs.js

`base.js`

```js
//创建公共地址的 比如：http://localhost:9999
//这样其他请求 公共部分无需编写了
const base = {
    baseUrl:"http://localhost:8082"
}
export default base;
```

`index.js`：这个文件不同的公司 名称可能不同 但是目的是一样的(调用之前封装好的请求 和 定义好的公共地址)

```js
//1.引入封装好的请求 当前文件和导入文件都是js 后缀js可以省略
import axios from '../util/request'
//2.引入封装好的公共地址
import base from './base'

//创建公共API接口 编写好了 以后发送不同模块网络请求都是引入这个api接口 来实现
//如果公司业务不同 这个也是经常修改的
const api = {
    //比如：post请求封装在一起
    postReq(url,data){
        return axios.post(base.baseUrl+url,data)
    },
    //比如：get请求封装在一起
    getReq(url,data){
        return axios.get(base.baseUrl+url,data)
    }
}

export default api;

//其他组件如何使用
// api.postReq('/add',data).then(res=>{})
```

- 如何使用封装好的api接口发送请求

```js
<template>
    <table>
        <tr>
            <td>编号</td>
            <td>账号</td>
            <td>密码</td>
            <td>姓名</td>
            <td>手机</td>
        </tr>
        <tr v-for="u in users">
            <th>{{ u.id }}</th>
            <th>{{ u.account }}</th>
            <th>{{ u.password }}</th>
            <th>{{ u.name }}</th>
            <th>{{ u.phone }}</th>
        </tr>
    </table>
</template>

<script setup>
import {ref, onMounted} from "vue"
import api from '../api/index'

const users = ref({})
//不需要我们触发 到了挂载生命周期 自动触发
onMounted(()=>{
    //由于没有参数传递 {} 占位置
    api.postReq('/show',{}).then(res=>{
        users.value = res.data.data.list
    })
})
</script>
```

## 9. 前端跨域

前端跨域一般可以通过前端vue项目的配置文件`vue.config.js` 添加一段配置 添加一个proxy代理对象 配置好后端地址 代理对象帮我们转发到目标地址

`vue.config.js`

```js
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  //将依赖进行转义，主要是用于增加代码在不同语言兼容性
  transpileDependencies: true,
  devServer:{
    //跨域代理对象
    proxy:{
      //可以配置很多组跨域 每组跨域都是一个对象
      // '/任意写':{配置好了跨域}
      // http://localhost:9999/任意写/show 就可以跨域了
      // /任意写/show 也可以跨域
      '/api':{//配置一个名为api的代理
        //配置后端地址 proxy会转发到这里去
        target:'http://localhost:8082',
        //路径重写 目的是去除请求地址中的/api
        pathRewrite:{"^/api":''},
        //代理webSockets 可以不配置
        ws:true,
        //开启跨域
        changeOrigin:true
      }
    }
  }
})
```

```
配置前：http://localhost:8082/show  -> 访问后端查询 但是会出现跨域问题
配置好后：/api/show -> http://localhost:8082/api/show
	再进行路径重写去除多余/api -> http://localhost:8082/show
```

如果请求封装了只需要修改`base.js`

```js
//创建公共地址的 比如：http://localhost:9999
//这样其他请求 公共部分无需编写了
const base = {
    // baseUrl:"http://localhost:8082"
    baseUrl:"/api"  //等价于http://localhost:8082
}
export default base;
```

==注：修改了vue.config.js 一定要重启服务器 否则不生效==

## 10. Vue路由 ---重点

路由主要用来管理vue组件中的关系 可以实现路径跳转 可以实现组件之间的传值，这样可以让vue.js 构建单页的应用更加轻松

#### 10.1 路由安装

- 通过vue ui界面安装

![70be1767ccd96b1c0acfaf866f6d4def](https://s2.loli.net/2024/08/26/wVf9BQq7cnpyRb2.png)

![fc49996fac20dd7f68857b851878a85e](https://s2.loli.net/2024/08/26/19lgKqrAmVbPsMc.png)

![1de49dcabc6468d4c254a24c1faa7db0](https://s2.loli.net/2024/08/26/LjfmHPz48VZwlKT.png)

- 通过创建vue项目选择route插件安装

==注：不要通过cnpm安装 语法都会通过 但是路由会失效，推荐使用vue ui图形界面方式安装依赖 ，或者创建vue项目的时候 选择路由插件==

#### 10.2 路由配置

创建一个包`src/router`用来保存路由配置文件(index.js) 通过路由管理所有vue组件，创建一个`src/views`包 用来保存所有被路由管理的vue组件 其他的vue组件依然可以保存在原来的components包

- views：创建组件的位置 比如：home.vue    user.vue
- router：创建一个index.js 编写路由规则(引入路由 路由规则 创建路由 导出路由)

```js
//1.导入路由组件对象
import { createRouter,createWebHashHistory } from "vue-router";
import home from '../views/home.vue'

//2.创建路由规则对象(数组 因为vue组件有很多个)
//routes 不能改
const routes = [
    {
        path:'/',    //访问的路径
        component:home
    },{
        path:'/user',
        //这种写法 属于异步加载 上面的方式属于同步加载
        //一般来说首页适合 同步加载 其他组件 都是异步加载
        component:()=>import('../views/user.vue')
    }
]

//3.创建路由组件
const router = createRouter({
    //配置路由历史模式,常用的两种历史模式（寻址方式）
    //createWebHashHistory：URL带#号，无需服务器支持，快速实现 比较常用 需要配合后端做重定向 否则会404
    //createWebHistory：更干净的URL，需服务器支持
    history:createWebHashHistory(),
    routes  //路由规则
})

//4.导出vue组件对象
export default router;
```

- mian.js：在vue项目的入口 启动vue 路由

```js
//引入路由 如果格式是js 可以省略后缀
//如果文件名就一个 叫index.js 都可以省略
import router from './router'

//使用路由 app创建之后 挂载之前 位置一定不能换
createApp(App).use(router).mount('#app')
```

#### 10.3 使用路由

- template中使用

在vue项目的首页(App.vue) 其他页面也可以添加 添加几个标签

```vue
<!--路由显示的入口-->
<router-view/>			<routerView/>

<!--等价于之前的a标签 链接标签-->
<router-link to="链接地址">链接名字</router-link>
```

- script中使用

```js
import { useRouter } from "vue-router";//导入路由 可以路由跳转
const router=useRouter();//定义路由对象
router.push("/login")
```

#### 10.4 路由传参

类似于后端 根据id传递后端 会在同一个页面显示不同的内容，而vue路由肯定也需要这种需求

- 路由配置地址的时候添加`:`表示 传递参数

```js
{
    path:'/user/:id/:name',
    component:()=>import("../views/user.vue")
}
//定义传递对象路由，二级也一样无需根目录
{
    path:'/test/:user',
    name: 'test',
    component: ()=> import("../views/Test.vue")
}
```

- router-link标签地址跳转时传入指定的数据(要根据配置的方式一样的)，发送方

```vue
<router-link to="/user/10/衣服">用户</router-link>
<!--传递对象 -->
<!--方式一:通过to写链接   数据要把对象转换成字符串传递-->
<route-link to="{name:'test',params:{ user: JSON.stringify(对象) }}">链接</route-link>
<!--方式一:通过push()   数据要把对象转换成字符串传递-->
<script setup>
    //发送方是useRouter
	import {useRouter} from 'vue-route'
    const router=useRouter()
    router.push({
        name:'test',
        params:{ user: JSON.stringify(对象) }
    })
</script>
```

- 进入指定的组件后 获取id和name属性值，接受方

```vue
<template>
	{{ $route.params.id }}
	{{ $route.params.name }}
</template>
<script setup>
    //接收方是useRoute
	import {useRoute} from 'vue-router'
    const route=useRoute()
    //获取发送的字符串对象
    const id=useRoute().params.id	
    const name=useRoute().params.name
    //接受对象
    console.log(route.params.user)
    //再转换成json对象
    console.log(JSON.parse(route.params.user))
</script>
```

#### 10.5 二级路由

如果项目中的功能特别复杂 会涉及到很多组件 肯定会出现父级导航 和子级导航，每个导航 都有很多子级组件 对应 就要涉及到二级路由或多级路由

- 路由配置文件添加属性`children`

```js
,{//一级路由
        path:'/article',
        component:()=>import('../views/article.vue'),
        redirect:'/article/history',//配置默认路由
        //二级路由 二级路由开始 地址不要加/
        children:[
            {
                path:'history',
                component:()=>import('../views/article/history.vue')
            },
            {
                path:'music',
                component:()=>import('../views/article/music.vue')
            }
        ]
    }
```

- 在一级路由组件页面中 通过`<routrr-link to="/一级/二级">`

```vue
<RouterLink to="/article/sports">体育栏目</RouterLink>
<div>
    <RouterView/>
</div>
```

==注：如果是三级路由，继续无限嵌套 理论上是没有上限的==

## 11. Elementplus

Elementplus应用场景非常广泛 比如：pc端 移动端 微信小程序 通常用于实现他们后台管理界面 提供很多编写好的可视化UI组件 如果环境搭建好了只需要Elementplus官网代码复制过来即可生效 是基于Vue3.0以上的版本 如果是Vue2.0版本兼容的是ElementUI

[官网](https://element-plus.org/zh-CN/)

#### 11.1 安装

通过Vue ui图形化界面安装依赖 参考路由的导入方式 搜索`elementplus`安装

![63516bdbe31c2ee10431a896b7b07028](https://s2.loli.net/2024/08/27/TPHIt1bVJZQpYMo.png)

==注：不推荐使用命令安装 因为会失效 原因在于elementplus内部有一个utils包也引入了vue 和安装的vue版本会有冲突==

#### 11.2 引入

- 完整引入：无论是否需要 不用在乎打包的项目大小 优点在于使用更方便

`main.js 以后main.ts`

```js
//1.导入elementplus
import Elementplus from 'element-plus'
import 'element-plus/dist/index.css'

//2.使用elementplus  如果导入了路由需要在路由之前使用 否者失效
createApp(App).use(Elementplus).use(router).mount('#app')
```

- 按需引入：应用场景比较广泛 会根据需要引入必要组件 比较节省空间 缺点在于需要做额外配置

  - 安装两个必要的插件 `components`和`auto-import`
    bug：插件的版本需要回退老版本 新版本不兼容

  ```
  cnpm install -D unplugin-vue-components@0.25.2 unplugin-auto-import@0.16.1
  ```

  - 修改`vue.config.js`配置文件 查看官网修改

  ```js
  const { defineConfig } = require('@vue/cli-service')
  // 按需引用添加的内容
  const AutoImport = require('unplugin-auto-import/webpack')
  const Components = require('unplugin-vue-components/webpack')
  const { ElementPlusResolver } = require('unplugin-vue-components/resolvers')
  module.exports = defineConfig({
    transpileDependencies: true,
    //需要加一个关键字
    configureWebpack:{
      //官网复制粘贴来的
      plugins: [
        AutoImport({
          resolvers: [ElementPlusResolver()],
        }),
        Components({
          resolvers: [ElementPlusResolver()],
        }),
      ]
    }
  })
  ```

  - main.js 还原 之前的全局引入删除

#### 11.3 使用

无论是按需引入还是全局引入 使用方式基本都是一样 只需要在elementplus组件官网找到需要的组件 查看源代码 复制到自己的vue组件中 刷新即可使用

#### 11.4 TypeScript

很多elementplus组件都要用到ts语法，所以创建项目要支持ts语法，axios 进行请求封装`uill/request.ts`时和api包下的`base.ts``index.tx` 都是使用.ts文件，还要修改一下ts的语法

index.ts中方法参数都需要添加类型，添加格式(参数1:类型,参数2:类型)，还要给data添加一个?允许传递空值
 ts语法 如果参数后面添加?表示可选参数

```js
// api/index.ts 代码片段案例
postReq(url:String,data?:Object){
    return axios.post(base.baseUrl+url,data)
}
```

#### 11.5 注册图标

由于Elementplus自己无论是按需导入还是全局导入 图标是不包含的，所以如果需要添加图标 需要做一些额外的配置

- 安装插件(elementplus/icons-vue)

```
vue ui 来安装，搜索element-plus/icons-vue安装
```

- 在main.js 或者main.ts 添加一段配置

```js
import { createApp } from 'vue'
import App from './App.vue'
import './registerServiceWorker'
import router from './router'
//引入所有的Elementplus图标
import * as ElementPlusIconsVue from '@element-plus/icons-vue'

const app = createApp(App)
//通过app组件遍历所有的elementplus图标 每遍历一个注册一个
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key, component)
}
app.use(router).mount('#app')
```

#### 11.6 调整大小bug

设计程序的时候 调整大小会报错 但是不会影响程序的执行，原因是出现Elementplus 他都有自己宽高 调整了大小 势必会影响它里面的组件，解决方案：可以在main.ts 添加一个定时器 让其改变大小有一些微小的间隔

```js
//随便加在main.js哪个位置
const debounce=(fn:any,delay:any)=>{
  let timer:any
  return (...args:any)=>{
    if(timer) clearTimeout(timer)
    timer=setTimeout(()=>{
      fn(...args)
    },delay)
  }
}
const _ResizeObserver = window.ResizeObserver;
window.ResizeObserver = class ResizeObserver extends _ResizeObserver{
  constructor(callback:any) {
  callback = debounce(callback, 200);
  super(callback);
  }
}
```

## 12. Vant

Vant是一个轻量级的 可以定制化移动端的组件库，使用方式类似于Elementplus，区别在于Vant 适用于移动端 小程序端 实现前台展示界面

[官网](https://vant-ui.github.io/vant/#/zh-CN)

#### 12.1 安装

推荐vue ui安装

通过Vue ui图形化界面安装依赖 参考路由的导入方式 搜索`vant`安装

#### 12.2 引入

推荐按需引入

- 安装插件

```js
//全部安装
cnpm i @vant/auto-import-resolver unplugin-vue-components unplugin-auto-import -D
//安装过elementplus 只需要装一个
cnpm i @vant/auto-import-resolver -D
```

- 配置vue.config.js，如果在官网中选择快速上手 按需导入 基于 vue-cli 的项目

```js
//在elementplus基础上添加一个导入包就好了
//在elementplus基础上 Vant额外导入
const { VantResolver } = require('@vant/auto-import-resolver');
```

elementplus基础上加一个红色框内就好

![image-20240829115204148](C:/Users/86134/AppData/Roaming/Typora/typora-user-images/image-20240829115204148.png)

#### 12.3 使用

vant官网复制粘贴



## 13. 常用函数

- 监听变量改变触发方法

```js
import {watch} from 'vue'
watch(值,(newValue,oldValue)=>{
    //当值发生改变的时候触发该方法，值是ref不用.value
})
//也可以监听多个变量的改变
watch([值1,值2],newValues,oldValues=>{
    const [new值1,new值2] = newValues;
    const [old值1,old值2] = oldValues;
})
```

## 14. JWT

#### 14.1 什么是JWT

JWT(JSON WEB Token)，它是跨域身份认证解决方案之一，通过json对象在前端和后端进行数据传递 主要用于实现用户的登录授权。比如：一旦用户登录成功，后端会返回一个token(令牌) 相当于后端给了前端返回了一个授权码，之后前端发送后端的每一个请求 都要携带这个token，后端在执行方法之前 会进行拦截校验token 校验通过了才能执行具体业务逻辑	

#### 14.2 JWT执行原理

![32](https://s2.loli.net/2024/08/30/Of6Uoyg4zmxSBcv.png)

#### 14.3 JWT组成

一个JWT中的token就是一个字符串，主要包含三个部分：Header(头信息)、PayLoad(载荷 存用户信息)、signature(签名)，这三个部分会通过`.`连接

比如一个完整的JWT Token 是：头部.载荷.签名

- 头部header：属于token第一部分 主要存放声明的加密算法

```js
{
    type:"JWT",		//声明令牌类型 JWT令牌 统一写JWT
    alg:"HS256"		//声明签名使用的算法
}
```

载荷：JWT第二部分 也是一个json对象 主要保存一些默认字段和用户需要传递的内容 通过Base64 算法将其转换成字符串保存

```js
//默认字段：
//iss(isuser):签发人/发行人
//sub(subject):主题
//aud(audience):用户
//exp:过期时间
//iat:签发时间
...
{
   //默认字段
    sub:'admin',
    //其他字段 可以自定义的 一般表示用户的信息
    username:'admin',
    name:'管理员',
    sex:'男'
}
```

- 签名：是JWT第三部分 首先需要指定一个密码secret(密码)，该sercet存储在服务端，保证不能让其他用户知道的 这个需要通过头部和载荷进行base64加密之后 通过`.`连接，然后通过头部声明加密算法 进行加密加盐 最后形成了一个签名

#### 14.4 springboot后端+Vue3.2前端+JWT整合

- pom.xml 添加依赖

```xml
<!--jwt依赖-->
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt</artifactId>
	<version>0.9.0</version>
</dependency>
```

- 提供两个方法(创建token-验证token)

```java
public class JwtUtils {
    private static long time=1000*60*60*24;//表示有效期为24h
    private static String signature="admin";//定义签名
    public static String createToken(){//创建token的方法
        //JwtBuilder用来构建jwt
        JwtBuilder jwtBuilder= Jwts.builder();
        String jwtToken=jwtBuilder
        //header
        .setHeaderParam("typ","JWT")
        .setHeaderParam("alg","HS256")
        //payload
        .claim("username","admin")
        .claim("role","user")
        .setSubject("admin-test")
        .setExpiration(new Date(System.currentTimeMillis()+time))//设置过期时间
        .setId(UUID.randomUUID().toString())
        //signature
        .signWith(SignatureAlgorithm.HS256,signature)
        .compact();//把三部分拼接起来
        return jwtToken;
    }
    //校验token的方法,其实就是解析token，如果解析成功就是可以放行
    public static boolean checkToken(String token){
        if (token==null){
        	return false;
        }
        try {
            Jws<Claims> claimsJws =
            Jwts.parser().setSigningKey(signature).parseClaimsJws(token);
        } catch (Exception e) {
        	return false;
        }
        	return true;
        }
}
```

- 前端vue发生一个登录请求给后端 ...
- 后端接收这个登录请求 验证登录成功和失败
- 如果验证登录成功了 使用创建的token的方法 生成一个token，再给登录的用户信息赋值(用户类添加一个token字段)，再一起统一返回前端

```java
@RequestMapping("/login")
public Result login(@RequestBody OAdmin admin){
    OAdmin login = as.login(admin);
    if (login!=null){
        //登录成功生成token保存
        login.setToken(JwtUtils.createToken());
        return new Result(1,"登录成功",login);
    }
    return new Result(0,"登录失败",login);
}
```

- 前端vue回调函数可以获取用户信息(有token)，再通过`localStorage`或者`sessionStorage`对其用户信息进行浏览器本地存储(为了方便其他vue组件获取使用的)

`登录请求中的回调函数`

```js
if(result.code==1){
    //存储登录成功的用户信息(通过浏览器本地保存)
    //localStorage 类似于之前的application
    //sessionStorage 类似于之前的session
    //存储时需要转换String类型 JSON.stringify()
    //可以在任何vue 或js 组件中使用
    let test = localStorage.setItem("admin",JSON.stringify(result.data));
    let token = localStorage.setItem("token",result.data.token);
    //弹窗提示登录成功
    //进入用户主页
}
```

- 配置前端拦截器使每次请求都携带token，在`request.tx`请求封装中配置，写在请求拦截器config方法中

```ts
//每次发送请求 都会进入这个拦截器进行 处理
//所以在这里编写 JWT存储请求头信息 表示所有进入后端的请求都会携带JWT 的token
const token = localStorage.getItem('token');
//请求头 存储的数据 不能识别中文
// config.headers.名称="数据"
config.headers.token=token;
```

- 后端配置拦截器验证token

`配置拦截器`

```java
@Component
public class TokenInterceptor implements HandlerInterceptor {
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        request.setCharacterEncoding("utf-8");
        String token = request.getHeader("token");
        if (token!=null) return true;
        response.setCharacterEncoding("utf-8");
        PrintWriter out = response.getWriter();
        //用于将java中的对象转成json
        out.write(new ObjectMapper().writeValueAsString(new Result(0,"认证失败")));
        return false;
    }
}
```

`拦截器配置类`

```java
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    @Autowired
    private TokenInterceptor interceptor;
    //配置类配置哪些请求被拦截 哪些请求放行
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(interceptor)    //添加拦截器对象
                .addPathPatterns("/**") //配置拦截的地址
                .excludePathPatterns("/oamin/reg","/oadmin/login"); //配置放行地址
        //调用父类的方法 才可以生效
        WebMvcConfigurer.super.addInterceptors(registry);
    }
}
```

#### 14.5 路由守卫

路由守卫是属于路由组件的一个重要功能，可以实现登录拦截功能，而且还可以设置拦截规则

`router/index.ts`写在export default router前

```ts
//添加路由守卫：控制哪些请求可以放行 哪些请求必须要登录
//to：要访问的地址  from：从哪个地址过来的
//next：表示放行    next('/login') 强制访问login
router.beforeEach((to,from,next)=>{
  //定义一个组件配置放行地址数组
  const exclude=['/login','/reg','/demo1','/demo3','/demo4']
  //如果访问的地址被exclude包含 则可以放行
  if(exclude.includes(to.path)) next()
  else {
      //如果不是放行的请求 判断是否登录过
      let token = localStorage.getItem("token")
      if(!token){//如果没有登录的token 则强制登录
          return next('/login')
      }
      //如果有登录的token 则正常访问
      next();
  }
})
```

## 15. iconfont矢量图

[官网](https://www.iconfont.cn/)	[vue3使用具体教程](https://www.jb51.net/article/283664.htm)

#### 15.1 vue3使用步骤

- 去 iconfont 官网，新建一个 iconfont 项目，存放自己的 iconfont。如下图所示：

![](https://img.jbzj.com/file_images/article/202305/202305090847101.png)

- 在项目 assets 目录下新建 iconfont 目录，在该目录下新建 iconfont.js 文件，然后将 iconfont 在线地址中提供的代码全部复制过来。注意每次新增了图标都要重新复制粘贴，如下图：

![202305090847102.png](https://img.jbzj.com/file_images/article/202305/202305090847102.png)

- 在 components 目录下新建 SvgIcon.vue 文件

```vue
// src/components/SvgIcon.vue
<template>
  <svg :class="svgClass" aria-hidden="true">
    <use :xlink:href="iconClassName" :fill="color" />
  </svg>
</template>
<script setup lang="ts">
import { computed } from 'vue';
const props = defineProps({
  iconName: {
    type: String,
    required: true
  },
  className: {
    type: String,
    default: ''
  },
  color: {
    type: String,
    default: '#409eff'
  }
});
// 图标在 iconfont 中的名字
const iconClassName = computed(()=>{
  return `#${props.iconName}`;
})
// 给图标添加上类名
const svgClass = computed(() => {
  if (props.className) {
    return `svg-icon ${props.className}`;
  }
  return 'svg-icon';
});
</script>
<style scoped>
.svg-icon {
  width: 1em;
  height: 1em;
  position: relative;
  fill: currentColor;
  vertical-align: -2px;
}
</style>
```

- 在 main.ts 中全局注册和引入 iconfont.js

```js
import SvgIcon from './components/SvgIcon/SvgIcon.vue'
import './assets/iconfont/iconfont.js';
const app = createApp(App)
app.component('SvgIcon', SvgIcon);
app.mount('#app')
```

- 项目中具体使用

```vue
<template>
  <svg-icon iconName="icon-gongzuoleixing"></svg-icon>
</template>
```



![image-20240831210804270](https://s2.loli.net/2024/08/31/CGMIoD3yRtJzuSY.png)

## 16. 文件上传

Vue+Vant+ELementplus+springboot实现文件上传

#### 16.1 测试

- 前端:Vue

  ```vue
  <template>
      <!-- Elementplus -->
      <div id="elementplus">
      <el-upload name="myFile" ref="uploadRef" action="/api/up1" list-type="picture-card" :auto-upload="false">
        <el-icon><Plus /></el-icon>
        <template #file="{ file }">
          <div>
            <img class="el-upload-list__item-thumbnail" :src="file.url" alt="" />
            <span class="el-upload-list__item-actions">
              <span
                class="el-upload-list__item-preview"
                @click="handlePictureCardPreview(file)"
              >
                <el-icon><zoom-in /></el-icon>
              </span>
              <span
                v-if="!disabled"
                class="el-upload-list__item-delete"
                @click="handleDownload(file)"
              >
                <el-icon><Download /></el-icon>
              </span>
              <span
                v-if="!disabled"
                class="el-upload-list__item-delete"
                @click="handleRemove(file)"
              >
                <el-icon><Delete /></el-icon>
              </span>
            </span>
          </div>
        </template>
      </el-upload>
    
      <el-dialog v-model="dialogVisible">
        <img w-full :src="dialogImageUrl" alt="Preview Image" />
      </el-dialog>
  
      <el-button class="ml-3" type="success" @click="submitUpload">
        upload to server
      </el-button>
      </div>
  
      <div id="vant">
      <!-- Vant -->
      <van-uploader :after-read="afterRead" v-model="fileList"
          multiple :max-size="500 * 1024" 
          @oversize="onOversize" />
      </div>
  
      <!-- Vant多文件上传 -->
      <van-uploader v-model="files" 
        :multiple="true"
        :after-read="afterRead2"/>
        <van-button type="primary" @click="upload">上传</van-button> 
    </template>
  
  <script lang="ts" setup>
  import { ref } from 'vue'
  import api from '@/api';
  import axios from 'axios'
  import { Delete, Download, Plus, ZoomIn } from '@element-plus/icons-vue'
  import type { UploadFile,UploadInstance } from 'element-plus'
  import { showToast,Uploader  } from 'vant';
  const uploadRef = ref<UploadInstance>()
  
  const dialogImageUrl = ref('')
  const dialogVisible = ref(false)
  const disabled = ref(false)
  const fileList = ref([]);
  const files = ref([]);
  const handleRemove = (file: UploadFile) => {
    console.log(file)
  }
  
  const handlePictureCardPreview = (file: UploadFile) => {
    dialogImageUrl.value = file.url!
    dialogVisible.value = true
  }
  
  const handleDownload = (file: UploadFile) => {
    console.log(file)
  }
  
  const submitUpload = () => {
    uploadRef.value!.submit()
  }
  
  const onOversize = (file) => {
        console.log(file);
        showToast('文件大小不能超过 500kb');
  };
  
  const afterRead = (file) => {
        // 创建FormData
        const formData = new FormData();
        formData.append('file', file.file);
        axios.post('/api/up2', formData, {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        })
        .then(response => {
          // 文件上传成功的处理逻辑
          console.log(response.data);
        });
  };
  
  
  const formData=new FormData()
  const afterRead2=(event)=>{
      const file=event.file
      formData.append("file",file);
  }
  const upload=()=>{
    // axios.post('/api/up3', formData, {
    //       headers: {
    //         'Content-Type': 'multipart/form-data',
    //       },
    //     })
    //     .then(response => {
    //       // 文件上传成功的处理逻辑
    //       console.log(response.data);
    //     });
  
    //使用封装好的请求(加个参数)
    api.uploadReq('/up3', formData,{
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        })
        .then(response => {
          console.log(response.data);
        });
  }
  </script>
  ```

- 后端:springboot

  ```java
  @RequestMapping("/up1")
      public Result up1(@RequestParam("myFile")
                        MultipartFile myFile){
          System.out.println(myFile);
          //调用业务层执行业务逻辑
          return new Result(1,"上传成功");
      }
      @RequestMapping("/up2")
      public Result up2(@RequestParam("file")
                               MultipartFile file){
          System.out.println(file);
          //调用业务层执行业务逻辑
          return new Result(1,"上传成功");
      }
      @RequestMapping("/up3")
      public Result up3(@RequestParam("file")
                                MultipartFile[] file){
          System.out.println(file);
          //调用业务层执行业务逻辑
          return new Result(1,"上传成功");
      }
  ```

- springboot配置文件

  ```properties
  spring.servlet.multipart.max-file-size=10MB
  spring.servlet.multipart.max-request-size=10MB
  ```



#### 16.2 ELementplus 上传多个文件包括用户数据到后端springboot

- 前端

  ```vue
  <template>
      <!-- 查询界面 -->
      <el-button type="primary" @click="addFormVisible = true">新增</el-button>
      <!-- 弹出层 -->
     <!-- 新增表单 -->
     <el-dialog v-model="addFormVisible" title="新增用户信息" width="500" draggable>
          <el-form ref="addFormRef"  :model="addForm" label-width="auto" class="demo-ruleForm" :size="size" status-icon>
              <el-form-item label="标题" :rules="[{ required: true, message: '标题不能为空', trigger: 'blur' }]">
                  <el-input v-model="addForm.title" />
              </el-form-item>
              <el-form-item label="描述">
                  <el-input v-model="addForm.description" />
              </el-form-item>
              <el-form-item label="天数" :rules="[{ required: true, message: '天数不能为空', trigger: 'blur' }]">
                  <el-input v-model="addForm.days" type="number" />
              </el-form-item>
              <el-form-item label="起始时间">
                  <el-date-picker v-model="addForm.startTime" type="date" placeholder="选择时间" style="width: 100%" />
              </el-form-item>
              <el-upload name="myFiles" v-model:file-list="uploadRef" list-type="picture-card" :auto-upload="false">
                  <template #file="{ file }">
                      <div>
                          <img class="el-upload-list__item-thumbnail" :src="file.url" alt="" />
                          <span class="el-upload-list__item-actions">
                              <span class="el-upload-list__item-preview" @click="handlePictureCardPreview(file)">
                                  <el-icon><zoom-in /></el-icon>
                              </span>
                              <span v-if="!disabled" class="el-upload-list__item-delete" @click="handleDownload(file)">
                                  <el-icon><Download /></el-icon>
                              </span>
                              <span v-if="!disabled" class="el-upload-list__item-delete" @click="handleRemove(file)">
                                  <el-icon><Delete /></el-icon>
                              </span>
                          </span>
                      </div>
                  </template>
              </el-upload>
          </el-form>
          <template #footer>
              <div class="dialog-footer">
                  <el-button @click="addFormVisible = false">取消</el-button>
                  <el-button type="primary" @click="add">提交</el-button>
              </div>
          </template>
      </el-dialog>
  </template>
  
  <script setup lang="ts">
  import { reactive, ref, onMounted } from 'vue'
  import type { ComponentSize, FormInstance } from 'element-plus'
  import api from '@/api';
  import axios from 'axios'
  import { Delete, Download, Plus, ZoomIn } from '@element-plus/icons-vue'
  import type { UploadFile, UploadInstance ,UploadProps} from 'element-plus'
  import { showToast, Uploader } from 'vant';
  import { ElMessage } from 'element-plus'
  const uploadRef = ref([])
  const dialogImageUrl = ref('')
  const dialogVisible = ref(false)
  const disabled = ref(false)
  const fileList = ref([]);
  const background = ref(true)
  
  const addFormVisible = ref(false)
  const addForm = ref({
      id:'',
      title: '',
      description: '',
      days: '',
      startTime: '',
      price: '',
      childPrice: '',
      startAddress: '',
      addressProvince: '',
      address: '',
      personNum: '',
      difficult: '',
  });
  const handleRemove = (file: UploadFile) => {
      console.log(file)
        // 从 fileList 中移除该文件
        const index = fileList.value.indexOf(file);
      if (index !== -1) {
          fileList.value.splice(index, 1);
      }
  }
  const handlePictureCardPreview = (file: UploadFile) => {
      console.log(file)
      dialogImageUrl.value = file.url!;
      dialogVisible.value = true; // 打开预览弹窗
  }
  const handleDownload = (file: UploadFile) => {
      console.log(file)
  }
  
  //新增函数
  const add = () => {
      console.log(addForm.value);
      const formData = new FormData();
     // 将 addForm 中的字段添加到 FormData
     Object.keys(addForm.value).forEach(key => {
          formData.append(key, addForm.value[key]);
      }); 
      const fileList = uploadRef.value;
      fileList.forEach(file =>{
               console.log(file,"头像")
              formData.append("myFiles",file.raw)   //获取出文件类型  存储到表单中
          }
      )
      // 发送请求
      api.postReq('/tourism/add', formData)
          .then(res => {
              console.log(res);
          })
  };
  ```

- 后端:

  ```
  @RequestMapping("/add")
  public Result add(@RequuestParam("myFiles")MultipartFile myFiles,User u){
     System.out.println(myFiles);
     System.out.println(u);
     //调用业务逻辑
     return new Result(1,"成功")
  }
  ```

  

#### 16.3 超简单

```vue
<template>
<van-uploader v-model="fileList" multiple />
<button @click="upload">上传</button>
</template>

<script setup>
import { ref } from 'vue';
import api from '../../../api/index'

//这是一个对象
const house = ref({});
const fileList = ref([]);

const upload = () => {
    // 创建 FormData 对象
    const formData = new FormData();

    //添加house对象
    formData.append('house',JSON.stringify(house.value))

    // 添加文件
    fileList.value.forEach((file) => {
    formData.append('files[]', file.file); // 'files[]' 是后端用来接收多个文件的字段名
    });

    // 发送请求
    api.postReq('/khouse/issue1',formData,{
        headers: {
            'Content-Type': 'multipart/form-data'
        }
    }).then(res=>{
        console.log(res);
    })
};
</script>

<style scoped>
/* 添加你的样式 */
</style>

```

```java
@RestController
@RequestMapping("/khouse")
public class KhouseController {
    @Resource
    ObjectMapper objectMapper;
    @RequestMapping("/issue1")
    public Result issue1(
            @RequestParam("house") Khouse house,
            @RequestParam("files[]")MultipartFile[] files,
            HttpServletRequest req) throws JsonProcessingException {
        // 解析 JSON 字符串为 Khouse 对象
        Khouse khouse = objectMapper.readValue(house, Khouse.class);
        System.out.println("Received Khouse: " + khouse);

        System.out.println("地址为："+UpdownUtil.getPath());
        // 处理文件
        for (MultipartFile file : files) {
            if (!file.isEmpty()) {
                // 一个文件上传工具类
                UpdownUtilSpringBoot.upload(req,file);
            }
        }
        return new Result();
    }
}

```

