# Spring

## 1. 什么是Spring?

spring是一个轻量级的`控制反转(IOC)`和`面向切面编程(AOP)`的容器框架，主要用来管理对象的生命周期的，这样就可以更加方便控制对象资源消耗，它集合了javaEE全功能解决方案

架构体系：

![e0ddfc41a5d9210ed7a6b90075b5d423](https://s2.loli.net/2024/08/13/ga82mxvphZPRyc6.png)

#### 1.1 spring框架体系介绍：

- core container：核心容器，主要通过BeanFactory管理对象的生命周期 
  控制哪些对象是单例模式，哪些对象是多例模式 他就是IOC
- spring AOP：面向切面编程 底层实现是jdk动态代理
- Date access：数据库访问模块 spring支持对于持久层框架的整合
  可以整合Mybatis   Mybatis plus   Hibernate   jdbc ...
- Web：控制层的功能 跟前端交互，spring支持对于控制层框架整合
  可以整合servlet、struts2、springMVC
- Test：测试模块 spring支持整合测试框架 整合junit

#### 1.2 spring依赖jar包

```xml
<!--spring依赖-->
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-context</artifactId>
  <version>5.0.3.RELEASE</version>
</dependency>
<!--aop依赖-->
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-aspects</artifactId>
  <version>5.0.3.RELEASE</version>
</dependency>
```

## 2. IOC ---重点

IOC就是控制反转，就是将控制对象控制权 交给spring容器去管理，这样spring就可以集中管理这些对象生命周期 哪些只需要创建一个(单例) 哪些对象需要创建多个 这样就可以节省整个项目的资源消耗。这种方式，对象控制权原来是我自己，后面交给spring容器 控制权由主动变成了被动 就是控制反转。

==IOC控制反转是如何实现的：是通过DI实现的==

```java
User u = new User();	//对象控制权是我自己
User u = spring容器创建; //对象控制权就是spring容器
```

#### 2.1 DI 

DI就是依赖注入，就是表示类和类依赖关系(依赖属性) 不用自己赋值 交给spring 会帮你自动注入(自动赋值)。注入过程中spring推荐你使用接口来当作依赖属性，因为接口可以提供很多种实现类 这样spring可以更加方便切换实现类 而不修改代码 这样就降低了各层之间的依赖关系 实现了解耦合

#### 2.2 DI依赖注入方式 ---面试题和笔试题

`java中如何使用bean对象`

```java
//读取spring配置文件(启动服务器有个组件给帮你读)
//ioc类型是ApplicationContext属于IOC容器对象，里面保存是spring创建所有bean
ApplicationContext ioc = new ClassPathXmlApplicationContext("spring-one.xml");
//参数可以为：bean的id(需要强转)/class对象(多个同类型bean找不到)/id,class对象(推荐)
User u1=(User) ioc.getBean("u");
User u2 = ioc.getBean(User.class);
User u3 = ioc.getBean("u",User.class);
```

- set注入：在类中给依赖属性 添加set方法，并且修改spring配置文件 添加`<bean>`标签标识对象，里面添加`<property>`标签给属性赋值，底层bean是通过无参构造来创建对象 创建对象后 通过set方法给依赖属性赋值

  优势在于：注入的属性 顺序和个数 都是可选的 所以set注入`适合复杂的依赖关系 更加直观`

```xml
<bean id="u" class="com.spring.pojo.User">
    <!--底层通过set() 来给属性赋值的-->
    <property name="name" value="张三"/>
    <property name="id" value="1"/>
    <property name="moeny" value="15.5"/>
    <!--时间类型特殊一点-->
    <property name="time">
        <!--相当于调用了sdf对象.parse()-->
        <bean factory-bean="sdf" factory-method="parse">
            <constructor-arg value="2012-10-20"/>
        </bean>
    </property>
</bean>
```

```xml
<bean id="sdf" class="java.text.SimpleDateFormat">
    <constructor-arg value="yyyy-MM-dd"/>
</bean>
```

- 构造方法注入：在类中添加有参构造方法 并且修改spring配置文件 添加`<bean>`标签表示对象，里面添加`<constructor-arg>`标签 配置有参构造的参数 底层是调用有参构造 在对象创建的时候 来完成所有属性的注入，如果有一个属性出现问题 就会创建对象失败 而且也会产生循环依赖的问题 所以它不适合做复杂关系注入

```xml
<bean id="u2" class="com.spring.pojo.User">
    <!--提供有参构造方法来注入：属性个数和顺序 根据构造方法定义来编写-->
    <constructor-arg value="2"/>
    <constructor-arg value="李四"/>
    <constructor-arg value="50.2"/>
    <constructor-arg>
        <bean factory-bean="sdf" factory-method="parse">
            <constructor-arg value="2020-08-10"/>
        </bean>
    </constructor-arg>
</bean>
```

- 注解注入：借助于IOC注解 和DI依赖注入注解来完成属性的注入

  - IOC注解：@Controller @Service @Repository @Component
  - DI注解：@Autowired(spring推荐使用) @Resource

  - 最后spring配置文件：一定要配置扫描包(不能忘了扫描 也不能多扫描)

```xml
<!--IOC扫描包：但是虽然以后可以写父包 里面的子包都可以扫描
    但是以后在SSM整合 不要这么写
    原因：spring 要扫描，springMVC 也要扫描
    如果写父包 扫描一定会重复扫描 会创建多个无用对象出来
    以后：spring只负责扫描业务层 springMVC只负责扫描控制层 dao层不用扫描 靠spring整合-->
<context:component-scan base-package="com.spring"/>
```



#### 2.3 循环依赖 --- 面试题

循环依赖就是两个类相互依赖，比如A类 依赖于B属性，B类也依赖于A属性。但是如果采用构造方法注入 会在对象实例化时借助于有参构造 来完成依赖关系，但A需要等B创建好 而B对象也需要等待A创建好，这就发生了循环依赖的问题

```xml
<!--假设A和B都提供有参构造-->
<bean id="a" class="A类">
	<constructor-arg ref="b"/>
</bean>
<bean id="b" class="B类">
	<constructor-arg 值/>
    <construct-arg ref="a"/>
</bean>
```

解决方案：

- 可以重新设计 不设计成相互依赖的情况
- 如果不能重新设计 可以使用set注入 或者 注解注入，原因：他们可以在不创建对象时 先利用无参构造把对象创建好 再完成依赖属性的注入
- 也可以添加一个@Lazy 延迟加载注解 可以对依赖注入添加该注解，这样这个依赖属性不会立马注入 只会注入一个代理对象 只有当首次使用时 才会完成对象实例化过程 进行注入

## 3. AOP ---重点





## 4. spring常用注解 ---面试题

- IOC扫描注解：一般是使用在类上面，spring配置文件必须提供扫描包 spring只要扫描到类上有这类的注解 它就会自动创建该类的对象(等价于spring帮你自动编写了bean标签) 下面四个注解底层实现都是一样的

  controller 和 service 和 repository 共同父类注解 都是 Component，只是标记的身份不同 而且还会提供默认bean的Id：类名首字母小写，如果想修改bean的Id：@IOC扫描注解("id")

  - @Controller：标注控制层的注解，因为只有控制层才能接受请求
  - @Service：标注业务层的注解，只有业务层才能正常完成事务
  - @Repository：标注mapper(dao)层注解，后期可以不用写，因为spring后期可以整合mybatis的mapper接口(创建它的实现类) 不是靠扫描创建出来的
  - @Conponent：标注其他层的注解 比如：过滤器 拦截器 插件 工具类

- DI注解注入注解：一般写在成员变量上的注解，用于通过spring IOC容器中的bean对象给该成员变量赋值，前提是：IOC容器必须有这个bean对象

  @Resource和@Autowired注解区别 ---面试题

  - @Autowired：是spring提供的注解，自动根据spring IOC容器 bean对象类型匹配，再根据依赖属性名 和容器中的bean的id匹配，如果匹配上了 则自动注入(赋值)，如果匹配不上spring则会抛出没有bean的异常。如果匹配上了 但是不止一个 spring也会抛出异常，因为spring不知道注入哪个类型

    ==解决方案：通过@Qualifier("bean的id") 用来指定使用哪个bean来注入==

  - @Resource：是java自带的注解，先匹配容器中bean的类型，匹配上了直接赋值 否则报错，如果匹配上了 但是不止一个，还可以根据bean的id去匹配关联属性名 也会自动赋值。如果关联属性名和Bean的id不同也可以@Resource(name="bean的Id")用来指定使用哪个bean来注入

- AOP注解：

- MVC注解：

  - @RequestMapping   @GetMapping	@PostMapping
  - @DateTimeFormat   @JsonFormat
  - @RequestBody   @ResponseBody
  - @RequestParam

- 其他注解：

## 5.  spring加载配置文件方式

- 添加MVC依赖 （包含spring监听器）

```xml
<!--spring版本一定要和springMVC版本是一致的 否则出现error-->
<!--springmvc核心依赖 -->
<dependency>
<groupId>org.springframework</groupId>
<artifactId>spring-webmvc</artifactId>
<version>5.0.3.RELEASE</version>
</dependency>
```

- 添加全局配置：配置spring配置文件地址

`web.xml`

```xml
  <!--全局配置：spring地址-->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath*:spring配置文件地址</param-value>
  </context-param>
```

- 配置spring提供的监听器：加载spring配置文件

`web.xml`

```xml
  <!--监听器：读spring配置文件-->
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
```

