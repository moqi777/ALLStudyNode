# SpringMVC

## 0. 为什么需要使用框架

框架类似于Java代码的模版 它已经完成了一部分（项目中的通用规范 接口 通用功能）编程人员只需要根据框架的使用规则 添加需要 就可以快速的写一个符合开发标准的项目 提高效率

## 1. 什么是SpringMVC ---面试题

谈谈你对SpringMVC理解？

SpringMVC是`spring框架的一个子项目`，`底层实现DispatcherServlet` 可以实现项目中`控制层`的功能（替换之前的Servlet）相比Servlet效率和性能都更高 并且SpringMVC和Spring是无缝连接

## 2. SpringMVC搭建步骤

#### 2.1 搭建环境

- 创建Maven项目（添加webapp）参考之前笔记
- 导入依赖(jar)pom.xml

```xml
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
    <spring.version>5.0.3.RELEASE</spring.version>
    <jstl.version>1.2</jstl.version>
    <servlet-api.version>4.0.0</servlet-api.version>
    <jsp-api.version>2.3.1</jsp-api.version>
    <jackson.version>2.9.0</jackson.version>
    <commons-fileupload.version>1.3.3</commons-fileupload.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <!--springmvc核心依赖 -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <!-- JSTL依赖：使用c:forEach c:if -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>jstl</artifactId>
      <version>${jstl.version}</version>
    </dependency>
    <!--servlet依赖-->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>${servlet-api.version}</version>
      <scope>provided</scope>
    </dependency>
    <!--jsp依赖-->
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>javax.servlet.jsp-api</artifactId>
      <version>${jsp-api.version}</version>
      <scope>provided</scope>
    </dependency>
    <!--json处理，相比于gson，这个可以自动转换，更好用-->
    <!--实际上为三个包，但是导入databind会自动导入其他两个包-->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>${jackson.version}</version>
    </dependency>
    <!--文件上传组件-->
    <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>${commons-fileupload.version}</version>
    </dependency>
    <!--自己添加自己版本的mysql驱动包-->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.33</version>
    </dependency>
    <!-- Lombok -->
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.22</version>
      <scope>provided</scope>
    </dependency>

  </dependencies>
```

- 配置SpringMVC配置文件

先创建controller包、创建resources包，创建配置文件，文件名自定义，然后在里面配置

![image-20240801104700955](https://s2.loli.net/2024/08/01/gnJvS9rP78FzOGC.png)

```xml
<!--配置什么东西？手敲根据提示导入-->
<!--1.配置控制层扫描包：扫描@Controller注解，扫描到了就会创建该类的对象-->
<context:component-scan base-package="com.sc.controller"/>
<!-- 2.开启注解驱动：让@RequestMapping生效，注意这里导入的包末尾是mvc，容易导错 -->
<mvc:annotation-driven/>
```

- 配置web.xml（配置SpringMVC核心）

```xml
  <!-- springMVC核心 DispatcherServlet -->
  <servlet>
    <!-- 随意一个servlet名称 -->
    <servlet-name>SpringMVC</servlet-name>
    <!--
      作用：1.作为springMVC入口，所有请求都需要经过这个Servlet才能到达SpringMVC
      作用：2.负责读取springMVC配置文件，默认读取WEB-INF下的文件
      文件名固定好了：servlet名称-servlet.xml
      通常配置文件 需要单独配置 不使用它默认的方式
    -->
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!-- 初始化参数：配置自定义配置文件 则就不读取默认位置了 -->
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <!-- classpath*: 根目录的意思 -->
      <param-value>classpath*:SpringMVC.xml</param-value>
    </init-param>
    <!-- 让其服务器启动 实例化 初始化(读取配置文件) -->
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>SpringMVC</servlet-name>
    <!--
       把进入控制层的请求配置好即可 不能写/*
       因为/*包含 *.jsp *.css *.jsp
       /的意思是只接收不带后缀的请求
    -->
    <url-pattern>/</url-pattern>
  </servlet-mapping>
```

- 配置tomcat 参考之前笔记

#### 2.2 测试成功

- 随便写个类 随便写个方法 通过几个简单的注解 就可以接接收请求处理请求

```java
//目的：没有任何作用 只表示当前这个类标记成控制层
//springMVC只要找到这个注解 就会创建控制层对象
@Controller
public class FirstController {
    @RequestMapping("/test")
    public void test(){
        System.out.println("进入测试方法");
    }
    @RequestMapping("/test2")
    public String test2(String name){
        System.out.println("进入测试2方法");
        return "这是我的结果";
    }
}
```

#### 2.3 解决中文乱码

- 在web.xml中`<display-name>`标签后面新增一个过滤器

```xml
  <!--springmvc提供编码过滤器-->
  <filter>
    <filter-name>encodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <!--  初始化参数：提供什么编码格式-->
    <init-param>
      <!-- 名字固定不可更改 -->  
      <param-name>encoding</param-name>
      <param-value>utf-8</param-value>
    </init-param>
  	<!-- 强制设置所有编码格式，选择性添加 -->
  	<init-param>
      <param-name>forceEncoding</param-name>
      <param-value>true</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>encodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
```

- 如果在返回的数据中还是出现了中文乱码，可以考虑设置一下响应的内容是什么，如果设置了这个，就可以完全代替原先在servlet中设置的编码过滤器功能，不过这个也需要单独设置。

```java
//// 设置内容类型为 HTML，并指定字符编码
resp.setContentType("text/html;charset=UTF-8");
//拼接js案例
resp.getWriter().print("<script>alert('" + "邮箱已存在" + "');location.href = '/register.jsp';</script>");
```

#### 2.4 放行静态资源

- springMVC会默认拦截静态资源(img css js) 需要让springMVC放行

```xml
<!-- 写在spring配置文件中 -->
<mvc:default-servlet-handler/>
```

## 3.  MVC三层架构 ---面试题

MVC是一种开发模式，也是软件设计风格，将一个系统分成M模型层 V视图层 C控制层 能够实现一个系统各个层级的解耦合

![0c669b2d510aec05b93e9eddbd07af8c](https://s2.loli.net/2024/08/01/FfbAC2ih6jTGedJ.png)

- M：model 模型层 主要用于处理业务逻辑(service)和数据访问(dao)
  service也叫业务模型 dao也叫数据模型

  - service：业务逻辑层 相当于一个功能 一个线程 专门用于处理事务
    因为以后功能会很复杂 可能会包括多次数据库操作 需要保证同时成功失败

  ```
  前端 用户实现用户下单功能：用户选择好商品 选择好数量 下单
  
  controller-- 接收下单的信息(商品信息 数量 价格 当前用户 ...)
  service-- 实现一个下单业务功能(包含5次dao操作 会调用5次dao层)要保证这5次dao层操作同时成功和失败 适合做事务 同时处理异常一般也在业务层解决 记录日志一般也会在这里编写
  
  商品dao-- 负责查询商品 
  用户dao-- 负责查询当前登录用户
  库存dao-- 负责查询库存是否充足 如果充足更新库存(减少库粗)
  订单dao-- 负责添加订单
  ```

  - dao：数据访问层 用于和数据库交互(jdbc mybatis)

- V：view视图层，主要用于提供可视化操作页面（html jsp vue） 

- C：controller控制层，主要是用于连接视图层和模型层 用户接收请求 处理请求的 控制哪个视图对应哪个模型(servlet springmvc springboot)

## 4. SpringMVC输入和输出

- 前后端不分离：前端代码和后端代码 在同一个项目，设计不到跨域问题

  - 输入：前端如何传递数据给后端(表单提交 或者 超链接地址栏传参)

  ```java
  //1.如果提交的是一个简单的数据(String int double...)
  //通过springMVC方法 添加形参 要求形参名必须和提交的name一致
  //比如：<a href="del?id=1">删除</a>
  //好处：不用像原来Servlet手动获取 也不用类型转换 会自动转换
  @RequestMapping("/del")//类似于servlet中的@WebServlet()注解
  public void test(Integer id){}
  
  //2.如果提交的是多个数据(比如：批量删除)
  //要求：前端提交name值 和ids形参名一致
  //注意：使用集合做参数  需要考虑 List是接口  不能实例化 只能写实现类
  //还需要添加一个注解@RequestParam("别名") 只能通过别名来识别   给哪个集合赋值
  //使用比较麻烦  不推荐使用      推荐使用数组
  public void test(Integer[] ids){}
  
  //3.如果提交的多个数据(比如：注册和新增)
  //可以在方法形参定义对象类型 要求name值必须跟属性名一致
  //注意：如果这个时候再增加一个形参和对象中的属性同名也能获取到值
  public void inAdd(Usermvc m,String name){}
  
  //4.如果提交的数据是包含日期 会出现400错误 需要格式转换
  //在传入的对象日期属性上(对象实体类中)添加一个注解@DateTimeFormat(日期格式)
  @DateTimeFormat(pattern = "yyyy-MM-dd")
  
  5.如果传输文件：单独讲 很特殊
  ```

  - 输出：后端处理完后 返回的数据给前端(作用域)

  ```java
  //springmvc底层实现 默认返回的是ModelAndView对象
  //模型和视图对象：模型就是要存储的数据（存储request作用域的数据）
  //视图就是要跳转的页面（默认转发）
  //springMVC底层返回需要ModeAndView 代码比较繁琐 不推荐 不推荐 不推荐
  @RequestMapping("/testOut")
  public ModelAndView test(ModelAndView modelAndView){
      // ModelAndView modelAndView = new ModelAndView();
      Usermvc u = new Usermvc();
      u.setName("张三");
      u.setMoney(19999.99);
      //等价于存储rquest作用域
      modelAndView.addObject("userMvc",u);
      //设置转发跳转的地址
      modelAndView.setViewName("/day1/show.jsp");
      return modelAndView;
  }
  ```

  ```java
  //推荐
  1.存储作用域：形参直接定义即可
  如果是request，定义：HttpServletRequest / Model / Map / ModeMap
  如果是session，定义：HttpSession
  如果是application，需要通过req获取，req.getServletContext()
      
  2.跳转作用域
  如果转发：属于默认 "/day1/show/jsp";//注意转发是相对地址，可以写/从根目录开始
  如果重定向："redirect:/day1/show.jsp";
      
  3.想使用其他类型的对象 request response session...
  直接在形参定义对应的类型 springMVC帮你自动赋值
  ```

- 前后端分离：前端是一个独立项目(vscode) 后端也是独立项目(idea) 两个项目是相互独立的 独立部署 两者没有影响的 功能的实现只需要通过前端项目发送请求 到另一个后端项目接受处理，涉及到跨域问题

  - 输入：前端 项目提交数据如何给后端接受
  
    - 前端：发送异步请求，同时要把提交的数据转换成json格式提交过来
  
    ```js
    axios.post('后端url',[json数据]).then(()=>{
       //then() 就是回调函数 
    });
    ```
  
    - 后端：方法形参添加@RequestBody 目的是用于接收前端提交json 转换成后端对象
  
    ```java
    @RequestMapping("/地址")
    pubilc XXX get(@RequestBody User u){
        
    }
    ```
  - 输出：后端项目发挥数据给前端去使用
  
    - 后端：方法上ResponseBody 目的是为了表示 返回值不是地址 是给前端项目响应的结果 也会自动转换成Json
  
    ```java
    @RequestMapping("/地址")
    @ResponseBody
    pubilc List<User> get(@RequestBody User u){
        return 集合;//后端会自动把集合转换成json 给前端
    }
    ```
  
    - 前端：发送的异步请求 会有一个回调函数（请求发送后成功的函数）这个回调函数的参数 就是后端返回的Json数据
  
    ```js
    axios.post('后端url',[json数据]).then((abc)=>{
       //abc 就是后端返回集合的Json数据
        console.log(abc);
    });
    ```

## 5. 文件上传和下载

==注意该工具类只适用于SSM项目==

#### 5.1 文件上传

- 前提

  - 前端：

  ```jsp
  1.请求方式只能是post方式
  2.数据的传递方式不能是字符串提交 需要设置附件提交
  <form action="" method="post" enctype="multipart/form-data"></form>
  ```

  - 后端：

  ```java
  1.springMVC配置文件 配置上传组件(允许接受文件)
  2.方法形参上MultipartFile类型表示文件类型
  3.方法形参名 也要和表单提交name一致的
  	bug：切记name不能和对象属性名一致，否则400错误
  @RequestMapping("/")
  public String add(Usermvc u,MultipartFile 非head){
      //Usermvc对象中有一个head属性，MultipartFile形参名不能同名，否则会报400
  }
  ```


- springMVC配置文件中配置上传组件（注意需要导文件上传包`commons-fileupload`）

```xml
<!--配置上传组件：id特殊 必须叫 multipartResolver ，因为这个bean被别的bean的ref引用了，id名字已经固定好了(在引用它的bean里的id就是这个值)，所以你这个bean的id也要一样-->
<!--一个bean表示java一个可重复组件(对象)-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <!--设置上传文件的编码-->
    <property name="defaultEncoding" value="utf-8"/>
    <!--设置上传文件的大小 单位：字节 10M=1024*1024*10-->
    <property name="maxUploadSize" value="10485760"/>
</bean>
```

- 编写文件上传UpDownUtil工具类

```java
//文件上传下载工具类：只适用于SSM项目
public class UpDownUtil {
    //上传通用方法
    public static String upload(HttpServletRequest req, MultipartFile multipartFile){
        //文件保存地址：存储在服务器的特定包（后期可以存储在云服务器）
        //假设在服务器定义一个包：upload 专门保存上传的地址
        //获取项目运行的真实路径 得到：真实路径+/upload/
        String path = req.getServletContext().getRealPath("/upload/");
        File file = new File(path);
        if (!file.exists()) file.mkdirs();
        //文件名：由于会替换不能拿上传名字保存 需要唯一处理
        // a.jpg 文件名(随机的：随机数 时间戳 UUID)+后缀名(固定不变的)
        //1.获取提交的文件名
        String oldName = multipartFile.getOriginalFilename();
        //2.获取后缀名
        int lastIndexOf = oldName.lastIndexOf(".");
        String suffixName = oldName.substring(lastIndexOf);
        //3.保存文件名需要随机 UUID：32位不重复的字符串
        String name = UUID.randomUUID().toString();
        //4.新文件名
        String newName = name+suffixName;
        File f = new File(path + newName);
        //开始上传
        try {
            multipartFile.transferTo(f);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return newName;
    }
}
```

#### 5.2文件下载

根据前端传来的文件名从服务器下载

`controller层`

```java
@RequestMapping("/download")
public ResponseEntity<byte[]> dowmload(String fileName,HttpServletRequest req){
    return UpDownUtil.download(fileName,req);
}
```

- UpDownUtil工具类中新增下载方法

```java
//下载通用方法
public static ResponseEntity download(String fileName,HttpServletRequest req){
    //1.获取请求头信息
    HttpHeaders headers = new HttpHeaders();
    //2.设置文档类型 原来默认是text/html 设置成流
    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
    byte[] bytes = new byte[0];
    try {
        //2.1设置文件名编码方式 如果文件名是中文也可以识别（可选）
        fileName = URLEncoder.encode(fileName, "utf-8");
        //3.指定附件形式下载，参数1：属性名附件；参数2：下载后的文件名
        headers.setContentDispositionFormData("attachment",fileName);
        //4.指定返回值 ResponseEntity<byte[]>
        //参数1：下载的文件的字节数组
        //参数2：请求头部信息
        //参数3：响应实体的状态(新建状态)
        File file = new File(req.getServletContext().getRealPath("/upload/") + fileName);
        bytes = FileUtils.readFileToByteArray(file);
    } catch (IOException e) {
        e.printStackTrace();
    }
    return new ResponseEntity<>(bytes,headers, HttpStatus.CREATED);
}
```

## 6. 分页

分页是一种将数据分段展示给用户的技术，用户每次看到的不是全部的数据，而是其中的一部分，用户可以通过页码数切换可见内容，类似于阅读书籍

#### 6.1 实现分页的步骤

- 会编写分页sql语句

```sql
select * from 表 where 条件 limit 起始下标,查询长度;
```

- 指定好页码数 和 每页条数

```sql
# 每页5条数据
select * from 表 limit 0,5; # 第一页
select * from 表 limit 5,5; # 第二页
select * from 表 limit 10,5; # 第三页
...
select * from 表 limit (当前页-1)*每页条数,5;
```

- 封装分页信息（工具类/Mybatis框架分页插件 pageHelper）

```java
当前页码
每页条数
总条数
总页数
每页的集合数据
```

- 将封装好的分页信息 传递给前端

#### 6.2 代码实现

`新建分页工具类`

```java
//页工具类：保存所有分页信息
//<T> 可以指定泛型 T只是个别名 名称可以为任意单词
//new PageInfo<User> T就表示User类型
//new PageInfo<Email> T就表示Email类型
//否则T就是Object类型
//使用该工具类需要先设置每页条数再设置总条数
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageInfo<T> {
    private int currentIndex;//当前页码--前端提供
    private int pageSize;//每页条数--后端和前端都可以提供
    private int totalCount;//总条数--数据库查询
    private int totalPage;//总页数--根据总条数和每页条数相除向上取舍得到的
    private List<T> list;//每页的集合数据--数据库查询

    //实现调用 设置总条数的同时 计算并赋值总页数。需要先设置每页条数再设置总条数
    public void setTotalCount(int totalCount) {
        this.totalCount = totalCount;
        //根据总条数 和每页条数 相除 向上取舍得到的
        totalPage = (int)Math.ceil(totalCount*1.0/pageSize);
    }
}
```

`controller层`

```java
@RequestMapping("/show")
public String show(HttpSession session,Map map, Integer currentIndex, Integer pageSize){
    //处理分页请求
    if (currentIndex==null) currentIndex=1;//第一次使用
    //如果传递过来了pageSize 存储起来
    //如果下一页过来 先获取是否存储过pageSize
    //如果没有值 才设置默认3
    if(pageSize!=null){//一定传了值
        session.setAttribute("pageSize",pageSize);
    }else {//没有传值
        pageSize = (Integer) session.getAttribute("pageSize");
        if (pageSize==null) pageSize=3;
    }
    //调用业务层service() 实现分页业务
    UsermvcService us = new UsermvcServiceImpl();
    PageInfo<Usermvc> p = us.show(currentIndex, pageSize);
    map.put("p",p);
    return "/day1/show.jsp";
}
```

`service层，此处省略了接口`

```java
public PageInfo<Usermvc> show(int currentIndex, int pageSize) {
    UsermvcDaoImpl ud = new UsermvcDaoImpl();
    PageInfo<Usermvc> p = new PageInfo<>();
    p.setCurrentIndex(currentIndex);
    p.setPageSize(pageSize);
    p.setTotalCount(ud.Count());//set方法内部计算好总页数
    p.setList(ud.show(currentIndex,pageSize));
    return p;
}
```

`dao层，此处省略了接口`

```java
public int Count() {
    String sql = "select count(1) from usermvc";
    ResultSet resultSet = DBUtil.select(sql);
    int count = 0;
    try {
        if (resultSet.next()) {
            count = resultSet.getInt(1);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    DBUtil.close(resultSet,DBUtil.pstmt,DBUtil.conn);
    return count;
}

public List<Usermvc> show(int currentIndex, int pageSize) {
    String sql = "select * from usermvc limit ?,?";
    ResultSet resultSet = DBUtil.select(sql,(currentIndex-1)*pageSize,pageSize);
    ArrayList<Usermvc> list = new ArrayList<>();
    try {
        while (resultSet.next()) {
            list.add(getOject(resultSet));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    DBUtil.close(resultSet,DBUtil.pstmt,DBUtil.conn);
    return list;
}

public Usermvc getOject(ResultSet resultSet) throws SQLException {
    Integer id = resultSet.getInt("id");
    String name = resultSet.getString("name");
    double money = resultSet.getDouble("money");
    Date time = resultSet.getDate("time");
    String head = resultSet.getString("head");
    return new Usermvc(id,name,money,time,head);
}
```

`show.jsp`

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=UTF-8" isELIgnored="false" language="java" %>
<html>
<head>
    <title>Title</title>
    <style>
        .num{
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 1px solid red;
            text-align: center;
            line-height: 20px;
            border-radius: 50px;
        }
    </style>
</head>
<body>
<a href="/day1/add.jsp">新增</a> <button>批量删除</button>
<table border="1" cellpadding="10" cellspacing="0">
    <tr>
        <th><input type="checkbox">全选</th>
        <th>编号</th>
        <th>姓名</th>
        <th>存款</th>
        <th>生日</th>
        <th>头像</th>
        <th>操作</th>
    </tr>
    <c:forEach var="u" items="${p.list}">
        <tr>
            <td><input type="checkbox"></td>
            <td>${u.id}</td>
            <td><a href="#">${u.name}</a></td>
            <td>${u.money}</td>
            <td>${u.time}</td>
            <c:if test="${empty u.head}">
                <td><img src="https://s2.loli.net/2024/08/02/MgH2iNkdstCPQKB.webp" alt="" style="width: 25px;height: 25px;"></td>
            </c:if>
            <c:if test="${not empty u.head}">
                <td><img src="/upload/${u.head}" alt="" style="width: 25px;height: 25px;"></td>
            </c:if>
            <td>
                <a href="#">删除</a>
                <a href="/usermvc/download?fileName=${empty u.head?'https://s2.loli.net/2024/08/02/MgH2iNkdstCPQKB.webp':u.head}"}>下载</a>
            </td>
        </tr>
    </c:forEach>
</table>
[${p.currentIndex}/${p.totalPage}]

<c:if test="${p.currentIndex>1}">
<a href="/usermvc/show?currentIndex=1">首页</a>
<a href="/usermvc/show?currentIndex=${p.currentIndex-1}">上一页</a>
</c:if>
<c:if test="${p.currentIndex==1}">
<a href="javascript:void(0)">首页</a>
<a href="javascript:void(0)">上一页</a>
</c:if>

<%--等价于标准for循环--%>
<c:forEach var="i" begin="1" end="${p.totalPage}">
    <a class="num" <c:if test="${p.currentIndex==i}">style="background-color: greenyellow"</c:if> href="/usermvc/show?currentIndex=${i}">${i}</a>
</c:forEach>

<c:if test="${p.currentIndex<p.totalPage}">
<a href="/usermvc/show?currentIndex=${p.currentIndex+1}">下一页</a>
<a href="/usermvc/show?currentIndex=${p.totalPage}">尾页</a>
</c:if>
<c:if test="${p.currentIndex==p.totalPage}">
<a href="javascript:void(0)">下一页</a>
<a href="javascript:void(0)">尾页</a>
</c:if>

<input id="page" type="text" size="1">页<button onclick="clickPage()">跳转</button>
每页条数
<select onchange="change(this)">
    <c:forEach var="i" begin="3" end="9" step="3">
        <option <c:if test="${p.pageSize==i}">selected</c:if>>${i}</option>
    </c:forEach>
</select>
</body>
<script>
    let clickPage = ()=>{
        let page = document.getElementById("page").value;
        //判断页码数小于1 或者 页码数 输入的不是数字
        if (page < 1 || isNaN(page)) page=1;
        //超过总页数
        if (page>${p.totalPage}) page=${p.totalPage}
        //如果当前页和输入的页数不一致 才发生请求
        if(page!=${p.currentIndex}) location.href="/usermvc/show?currentIndex="+page;
    }
    let change = (o)=>{
        location.href = "/usermvc/show?pageSize="+o.value;
    }
</script>
</html>
```

`效果`

![image-20240805173003474](https://s2.loli.net/2024/08/05/jMqbBEpTir8PxzI.png)

## 7. 视图解析器



## 8. SpringMVC工作流程



## 9. SpringMVC拦截器