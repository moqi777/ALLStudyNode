# Vue3

## 1.前端环境搭建

#### 1.1 安装和配置vscode

- 下载群里vscode.exe 安装包 双击运行
- 设置 --> setting

`修改字体大小`

![修改字体大小](https://s2.loli.net/2024/08/20/5UJv2IlcCQuhmEO.png)

`修改主题`

![修改主题](https://s2.loli.net/2024/08/20/yeOYRqISHh5pisP.png)

`修改终端字体大小`

![修改终端字体大小](https://s2.loli.net/2024/08/20/6ro3VjDku9b2fZQ.png)

- 安装Vue3插件(之前版本volar被弃用) 安装新版本，否则使用vue3的语法会出现错误

![43b0e30bb6154e17803ed8abf9f1153d](https://s2.loli.net/2024/08/20/ZzJ1rjuKNW6Ds5R.png)

#### 1.2 vscode快速生成vue3模版

File(文件) -> Preferences(首选项) -> Configure Snippets(配置代码片段) -> 弹出输入框搜索vue(或者vue json)进入 -> 弹出窗口将下面json替换进去就可以

使用：在新建的vue文件 输入vue3 回车就可以生成模版

```json
{
"Print to console": {
"prefix": "vue3", //vue文件输入代码前缀
"body": [ //主体自动生成的代码格式
"<template>\n",
"</template>\n",
"<script setup>",
"import {ref} from \"vue\"",
"</script>\n",
"<style scoped>\n</style>",
"$2"
],
"description": "Log output to console"
}
}
```

#### 1.3 安装和配置node.js

node.js类似于java的jdk 是vue项目的运行环境 而且版本也很重要，如果是vue3 最低支持node14以上版本，具体看`node安装使用笔记.md`

#### 1.4 npm 和 cnpm

npm是node官方提供包管理器 cnpm是中国版的npm，是淘宝定制的命令行 用于替代npm 如果网络原因导致无法使用 推荐使用cnpm

- 安装方式：通过cmd，注意管理员身份运行

```
npm install -g cnpm --registry=https://registry.npmmirror.com/

安装成功：cnpm -v
```

#### 1.5 安装vue脚手架

vue脚手架 是用于快速构建vue项目的 类似于之前使用的maven，安装过程比较繁琐，可能会失败很多次，多装几次就好了

- 安装命令，注意管理员身份运行

```
cnpm install -g @vue/cli
测试：vue -V
```

#### 1.6 设置镜像地址

设置npm和cnpm地址都设置成淘宝镜像地址

```
npm config set registry https://registry.npmmirror.com/
cnpm config set registry https://registry.npmmirror.com/
```

## 2. Vue如何创建项目

如果一直创建项目失败可以尝试右键桌面vcCode图标 -> 属性 -> 兼容性 -> 以管理员身份运行此程序

- crtl+` 打开终端
- 输入命令创建项目：`vue create 项目名(必须小写)`
- 选择vue项目模版格式

```
  Default ([Vue 3] babel, eslint)		->vue3模版只带两个插件
  Default ([Vue 2] babel, eslint)       ->vue2模版只带了两个插件                   > Manually select features 			  -> 推荐手动选择插件
```

- 选择项目需要支持的插件，可以根据用户需要自由组合，使用上下箭头可以切换，`空格选中`，`回车确认`

```
>(*) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 ( ) Router
 ( ) Vuex
 ( ) CSS Pre-processors
 (*) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing
```

```
Babel：一个js编译器转码器 可以将ES6转换成ES5代码，主要用于向下兼容，必加项
TypeScript：底层就是对于js做了一个封装，相当于一种面向对象的js，简称ts，运行时也会转换成js		后期必导，如果选择了会有两个子菜单... 
	Use class-style component syntax? (y/N) 是否使用类风格装饰器(y)
	Use Babel alongside TypeScript  Babel和Ts是否一起使用(y)
web App：属于web应用程序，必加项
Router：vue路由，通过请求链接到具体哪个vue组件的(跳转)，后期必导
	Use history mode for router?  配置路由历史模式 选N
Vuex：vue的状态管理模式，可以保存一些vue中的对象
CSS：css预处理器，一般不导
Linter / Formatter：代码风格检查和格式化，用于检查代码是否符合规范的，不导慎用
Unit Testing：单元测试插件，类似于Java的junit
E2E Testing：(end to end) 端到端的测试
```

- 配置 配置文件放在哪里 是默认位置还是放在package.json中，推荐使用默认

```
> In dedicated config files		-> 使用默认位置
  In package.json				-> 放入package.json
```

- 是否保存历史配置，可以保存上一次创建vue插件配置，可以让我们更加快捷创建项目，后期可以使用，当前选N。保存的模版在 `C:\Users\86134\.vuerc`中可以查看，删除模版也在这里

```
Save this as a preset for future projects? (y/N)
```

- 项目创建成功后

```
cd 项目名   		-> 进入项目
npm run serve	  ->启动项目
```

你也可以使用`vue ui`命令打开图形化界面管理vue项目

## 3. 什么是Vue

vue是一个前端框架，免除一些原生的javascript中的繁琐的dom操作，是基于MVVM(Model-View-ViewMode)思想，用于实现数据双向绑定，使开发者只关注于数据即可

- MVVM思想：可以用于实现数据双向绑定，就是模型的数据(Mode) 发生了改变 页面展示的数据(View)也会改变，反之如果展示的数据发生修改了 模型的数据也会发生改变。VM(ViewModel)就是用于实现Model和View之间数据双向绑定 通常ViewModel是通过js实现的(Vue对象)

==vue2是选项式API，默认就是响应式数据。vue3是组合式API，默认是引用式数据，所以需要通过`ref`改为响应式数据==

#### 3.1 项目目录结构

![image-20240821144554938](https://s2.loli.net/2024/08/21/tSJVgm7LTiqhaAC.png)

- node_modules：运行vue项目需要第三方组件或者插件 类似于maven导入的依赖(jar) 如果删掉了 只需要`vue install`重新安装回来
- public：vue项目提供默认图标首页 一般vue项目写完后进行打包时 会默认存储在这个位置 会把vue项目的组件转换成css/html，输入命令`vue build`打包，/public访问资源
- src：重点目录
  - asses：存储静态资源的位置 css img...，../assess访问资源
  - components：存放vue组件的目录，创建所有的vue页面都放在该目录下，但是以后添加了路由router 就放在router包
  - App.vue：Vue核心组件 所有组件都必须经过App组件 否则失效，因为它是Vue项目的默认首页
  - 类似于java的main方法 程序的入口
  - registerServiceWorker.js：存储一些监听的 不重要
- package.json：等价于之前maven项目中的pom.xml，vue项目安装所有插件和第三方组件都可以在这里查看
- vue.config.js：等价于springboot中的application.properties vue项目的唯一配置文件   ==注：配置文件只要修改 必须重启Vue项目==

## 4. Vue基础语法

```vue
<!--表示编写html内容-->
<template></template>

<!--表示编写vue业务逻辑的，通过js基础编写的 vue2语法-->
<script>
    //导出当前默认组件
	export default{}
</script>

<!--属于vue3语法 可以不用写export data() return...-->
<script setup></script>

<!--编写css-->
<!-- scoped 是为了设置样式不影响其他组件 -->
<style scoped></style>
```

#### 4.1 vue声明变量的方式有哪些 ---面试题

- var：通常用于定义全局变量，允许重复声明
- let：ES6新增的，用来替代var的，只能作用于局部区域，不能重复声明
- const：ES6新增的 用来声明常量的(最常用的) 只能作用于局部区域 不能重复声明

```vue
<script setup>
    import {ref} from 'vue'
    const user=ref();
    //这样user对象地址不能改 但是对象里面的属性是可以修改的
</script>
```

#### 4.2 vue基本指令

指定：就是html标签里面添加带有v-前缀的特殊属性，不同指令具有不同的函数，而vue是通过这些指令来实现页面动态的效果 

| 指令                    | 作用                                                |
| ----------------------- | --------------------------------------------------- |
| v-bind（:）             | 为html标签绑定属性值 比如设置href css样式，单项绑定 |
| v-model                 | 为表单元素创建双向数据绑定的，双向绑定              |
| v-if  v-else=if  v-else | 条件性渲染元素                                      |
| v-show                  | 条件性渲染元素                                      |
| v-for                   | 列表渲染 遍历下面定义集合和数组变量的               |
| v-on（@）               | 为html标签绑定事件                                  |

==vue2 v-if 和 v-for同时使用优先级 v-for > v-if
vue3 v-if 和 v-for 同时使用优先级 v-for < v-if
vue3 v-show 和 v-for 同时使用优先级 v-for > v-show==

- v-binf指令和v-model指令 

`v-model.lazy`：懒加载，输入结束后才会同步
`v-model.trim`：去除前后空格

```vue
<template>
    <!-- v-bind 用于绑定属性值
        将下面vue创建的变量 给标签属性值使用 -->
     <a v-bind:href="url">链接1</a>
     <!-- v-bind可以省略 -->
     <a :href="url">链接2</a>
     <!-- 借助于双向绑定修改url的值 -->
      地址：<input v-model="url">
</template>

<script setup>
import {ref} from 'vue'
const url = ref('http://www.baidu.com')
</script>
```

- v-if指令和v-show指令

区别：---面试题

​				if底层不满足就不会去渲染标签 所以标签是不存在的
​        	  show底层通过display是否切换none来显示隐藏的  标签都是存在的 但是有的隐藏了看不到

```vue
<template>
    <div v-show="status==1">show启用</div>
    <div v-show="status==0">show禁用</div>
    <div v-show="status==2">show未验证</div>

    <div v-if="status==1">启用</div>
    <div v-else-if="status==0">禁用</div>
    <div v-else-if="status==2">未验证</div>
    <div v-else>冻结</div>
    <input v-model="status">
</template>

<script setup>
import {ref} from 'vue'
const status = ref(1)
</script>
```

- v-for指令

```vue
<!--语法规则，集合和数组需要在js中定义好变量-->
<标签 v-for="临时变量 in 集合或数组">
	{{临时变量}}    
</标签>
<!--语法规则2：如果页面需要变量的数据的索引-->
<标签 v-for="(临时变量,索引变量) in 集合或数组">
	{{索引变量+1}}    {{临时变量}}
</标签>
```

```vue
<template>
    <table>
        <tr>
            <th>序号</th>
            <th>编号</th>
            <th>地址</th>
        </tr>
        <tr v-for="va in address">
            <td></td>
            <td>{{ va.id }}</td>
            <td>{{ va.addrname }}</td>
        </tr>
        <hr>
        <tr v-for="(va,i) in address">
            <td>{{ i }}</td>
            <td>{{ va.id }}</td>
            <td>{{ va.addrname }}</td>
        </tr>
    </table>
</template>

<script setup>
import {ref} from 'vue'
const address = ref([
    {id:8,addrname:'南昌'},
    {id:7,addrname:'北京'},
    {id:10,addrname:'上海'},
    {id:12,addrname:'济南'}
])
</script>
```

- v-on指令

```vue
<template>
    <div>
        <input type="button" value="确认" v-on:click="show()"/>
        <!-- 但是以后编写 v-on: -> @ -->
        <input type="button" value="确认@" @click="show()"/>
    </div>
</template>

<script setup>
import {ref} from 'vue'
const show = ()=>{
    console.log("hello");
}
</script>
```

## 5. 组件基础

Vue是基于组件开发的，我们创建每一个*.vue文件 它是一种特殊的文件格式，在vue中称这种文件叫做Vue组件(html 样式css 业务逻辑js)。一个组件的组成部分在`4.Vue基础语法`章节中中写了

#### 5.1 加载组件步骤

- 引入组件：javascript标签内

```js
import 组件名(可以自定义) from "./compontens/XXX.vue"
```

- 挂载组件：javascript标签内==如果使用vue3.2 setup语法糖 可以省略挂载组件==

`vue2版本`

```js
export default{
	components:{
        组件名1,
        组件名2,
        ...
	}	
}
```

`vue3版本`

```js
<script setup>
import { defineComponent } from "vue"
//vue3.2需要使用defineComponent()
defineComponent({
    components:{
        组件名1,
        组件名2,
        ...
    }
})
</script>
```

- 显示组件：template标签内编写

```html
<组件名/>
```

#### 5.2 组件的交互(父->子) ---面试题

组件和组件之间如果没有任何关系 就没有意义了 他们之间是可以进行交互的，比如：a组件的数据 交给b组件使用 通过prop来组件交互

- 老版本传递方式

  - 父组件

  ```vue
  <template>
      <h3>父组件</h3>
      <!-- vue老版本 通过:属性名(任意) 属性值就是要传递的数据(可以传递任意数据) -->
      <!-- 就是 v-bind 绑定属性名 只不过属性是任意编写 -->
      <two :myAge :name="myName" :user="myUser" :list="myList"/>
  </template>
  
  <!-- vue老版本 -->
  <script>
  import two from './Child.vue'
  export default{
      components:{
          two
      },
      data(){
          return{
              myAge:20,
              myName:'张三',
              myUser:{id:1,sex:'男',class:'sc240601'},
              myList:['java','mysql','js','vue']
          }
      }
  }
  
  </script>
  ```

  - 子组件

  ```vue
  <template>
      <h3>子组件</h3>
      <h3>年龄：{{ myAge }}</h3>
      <h3>姓名：{{ name }}</h3>
      <h3>对象：{{ user.id }}  {{ user.sex }}  {{ user.class }}</h3>
      <h3>集合数字：
          <span v-for="s in list">{{ s+" " }}</span>
      </h3>
  </template>
  
  <script>
      export default{
          // 通过props来接收父组件传递的数据
          //age就是父组件传递过来的属性名(自定义的)
          props:{
              myAge:{type:Number,default:0},
              name:{type:String,default:""},
              user:{type:Object,default:null},
              list:{type:Array,default:[]}
          }
      }
  </script>
  ```

- 新版本传递方式

  - 父组件

  ```vue
  <template>
      <h3>父组件</h3>
      <!-- 3.显示子组件 -->
      <!-- vue老版本 新版本都类似于 通过:属性名(任意) 属性值就是要传递的数据(可以传递任意数据) -->
      <!-- 就是 v-bind 绑定属性名 只不过属性是任意编写 -->
      <two :myAge :name="myName" :user="myUser" :list="myList"/>
  </template>
  
  <script setup>
  import { defineComponent, ref } from "vue"
  //1.引入组件
  import two from './Child.vue'
  //2.挂载组件 vue3.2需要使用defineComponent()
  defineComponent({
      components:{
          two
      }
  })
  const myAge = ref(18)
  const myName = ref("李四")
  const myUser = ref({id:1,sex:'男',class:'sc240601'})
  const myList = ref(['java','mysql','js','vue'])
  </script>
  ```

  - 子组件

  ```vue
  <template>
      <h3>子组件</h3>
      <h3>年龄：{{ myAge }}</h3>
      <h3>姓名：{{ name }}</h3>
      <h3>对象：{{ user.id }}  {{ user.sex }}  {{ user.class }}</h3>
      <h3>集合数字：
          <span v-for="s in list">{{ s+" " }}</span>
      </h3>
  </template>
  
  <script setup>
  import {} from "vue"
  //vue3.2 通过defineProps来接收父组件的值
  defineProps({
      myAge:{type:Number,default:0},
      name:{type:String,default:""},
      user:{type:Object,default:null},
      list:{type:Array,default:[]}
  })
  </script>
  ```

  

#### 5.3 组件的交互(子->父) ---面试题

子组件想传值给父组件借助于自定义事件，如果是vue之前的版本 借助于this.$emit(自定义事件，数据) 如果是新版的方式 通过导入defineEmits() 创建一个触发器绑定自定义事件

- 老板实现方式

`父组件`

```vue
<template>
    <h3>父组件</h3>
    <h3>父组件接收的数据：{{ result }}</h3>
    <two @childSend="getChildSend"/>
</template>

<script>
import two from './Child.vue'
export default{
    components:{
        two
    },
    data(){
        return{
            result:""
        }
    },
    methods:{
        // 方法参数：就是子组件传递来的数据
        getChildSend:function(result){
            this.result=result
        }
    }
}
</script>
```

`子组件`

```vue
<template>
    <h4><button @click="send">发送数据</button></h4>
    <h4><input v-model="msg"></h4>
</template>

<script>
    export default{
        data(){
            return{
                msg:""
            }
        },
        methods:{
            send:function(){
                //this.$emit用于向父组件传递数据
                //参数1：自定义事件名；参数2：传递的数据(任意类型)
                this.$emit("childSend",this.msg)
            }
        }
    }
</script>
```

- 新版实现方式

`父组件`

```vue
<template>
    <h3>父组件</h3>
    <h3>父组件接收的数据：{{ result }}</h3>
    <two @childSend="getChildSend"/>
</template>

<script setup>
import { defineComponent, ref } from "vue"
//1.引入组件
import two from './Child.vue'
//2.挂载组件 vue3.2需要使用defineComponent()
defineComponent({
    components:{
        two
    }
})
const result = ref();
const getChildSend = (res)=>{
    result.value=res
}
</script>
```

`子组件`

```vue
<template>
    <h4><button @click="send">发送数据</button></h4>
    <h4><input v-model="msg"></h4>
</template>

<script setup>
import { ref,defineEmits } from "vue"
//defineEmits() 返回一个触发器 用于触发自定义事件
//childSend 自定义方法名，可以多个
const emit = defineEmits(['childSend'])
const msg = ref();
const send = ()=>{
    //绑定值
    emit('childSend',msg.value)
}
</script>
```

==注：上面几种传递方式前提组件具有父子关系，如果没有父子关系借助于路由来传递数据==

==注：箭头函数中不要用this会出错==

## 6. 组件生命周期 ---面试题

组件在被创建或者使用时都会经过不同的阶段 比如：设置数据监听，实例挂载到组件中 ... 每经过一个阶段 都会运行一些生命周期函数 用于给用户实现不同阶段完成不同的业务逻辑

声明周期一共有八个阶段：每触发一个阶段都会自动运行一个生命周期的函数，这些生命周期函数 也叫钩子函数

| 状态(钩子函数) | 阶段周期                  |
| -------------- | ------------------------- |
| beforeCreate   | 创建前阶段                |
| created        | 创建后                    |
| beforeMount    | 载入前 渲染前             |
| mounted        | 挂载完成 渲染后           |
| beforeUpdate   | 更新前 页面数据发生了变化 |
| updated        | 更新后 页面数据发生了变化 |
| beforeDestory  | 销毁前                    |
| destoryed      | 销毁后                    |

![ffaf9787c468ae94a307b520c4ec8f17](https://s2.loli.net/2024/08/22/cPEXdSKRZn6OFAh.png)

#### 6.1 代码实现

`老版代码实现`

```vue
<template>
<input v-model="msg">
</template>

<!-- 老版钩子函数 和 methods 是同级的-->
<script>
export default{
    data(){
        return{
            msg:"呵呵"
        }
    },
    //函数的位置
    methods:{

    },
    // 钩子函数：随着生命周期的变化自动触发
    //页面刚刚加载，会根据不同生命周期阶段执行下面4个函数
    beforeCreate:()=>{
        console.log("创建前");
    },
    created(){
        console.log("创建后，创建一些vue核心对象");
    },
    beforeMount:function(){
        console.log("挂载前");
    },
    //最常用的 经常需要在这里加载后端数据
    mounted(){
        console.log("挂载后，页面已经渲染完毕，可以在前端看到效果了");
    },
    //当任意数据发生改变 会执行下面的两个函数
    beforeUpdate(){
        console.log("更新前");
    },
    updated(){
        console.log("更新后");
    },
    //当组件销毁 看不到效果的 会自动执行下面两个函数
    beforeDestroy(){
        console.log("卸载前");
    },
    destroyed(){
        console.log("卸载后");
    }
}
</script>
```

`新版代码实现`

```vue
<template>
<input v-model="msg">
</template>
<!-- 新版钩子函数
     跟旧版相比 新版的vue方式beforeCreate和created 已经被调用了
     所以这两个函数在使用时是可以忽略的
     需要导入对应的函数名(on钩子函数) 通过import
     而且每种钩子函数可以编写多个 -->
<script setup>
const msg = ref()
import {onMounted, onUpdated, ref} from "vue"
onMounted(()=>{
    console.log("挂载后");
})
onUpdated(()=>{
    console.log("更新后");
    
})
</script>
```

## 7. Vue引入第三方

第三方不属于vue，是其他人写好可以基于vue来实现很多常用功能，不需要我们自己再单独编写，而我们只需要学习如何引入这些成熟第三方即可

比如：ElementPlus(前端后台页面 面向pc端)、Vant(前端前台页面 面向移动端)、swiper(免费触摸滑动 轮播组件 面向pc端 移动端 平板端都可以) ...

#### 7.1 vue引入swiper第三方

[官网](https://www.swiper.com.cn/)

- vue项目中(项目根目录下)安装swiper

```
-- 安装最新版swiper
cnpm install --save swiper
-- 可以指定版本安装
cnpm install --save swiper@10.2.0
```

- 在组件中导入swiper，类似于之前学习的组件引入

`案例`

```vue
<template>
    <!-- 
        modules：类似于v-model 做双向绑定的 只不过它是绑定很多变量
        需要在下面定义好数组的变量
        navigation：使用上一页下一页
        pagination：开启页码指示器
        autoplay：自动播放
    -->
    <Swiper 
    :modules="modules"
    navigation
    :pagination="{clickable:true}"
    :autoplay="{delay:5000}"
    mousewheel
    >
        <SwiperSlide>
            <img src="../assets/logo.png"/>
        </SwiperSlide>
        <SwiperSlide>
            <img src="../assets/logo.png"/>
        </SwiperSlide>
        <SwiperSlide>
            <img src="../assets/logo.png"/>
        </SwiperSlide>
    </Swiper>
</template>
<!-- 如果使用vue3.2 setup语法糖 可以省略挂载组件 -->
<script setup>
import {Swiper,SwiperSlide} from "swiper/vue";
import {Autoplay,Navigation,Pagination,Mousewheel} from 'swiper/modules'
import 'swiper/css';
import 'swiper/css/navigation'
import 'swiper/css/pagination'
import 'swiper/css/mousewheel'
const modules=[Autoplay,Navigation,Pagination,Mousewheel]
</script>
```

## 8. Vue发送异步请求

#### 8.1 发送异步请求

- 原生js实现的，步骤比较复杂 不推荐
- jQuery封装好的方法 $.post() $.get() $.ajax()，但是需要手动控制请求和响应的数据格式 不推荐
- 通过axios发生异步请求 底层就是对jQuery的ajax进一步的封装，非常适合前后端分离的项目 它默认的传输格式就是Json 推荐使用

#### 8.2 axios安装和使用

- 安装命令

```
cnpm install --save axios
```

- 引入axios
  - 通过`import axios from 'axios' ` 这样使用的话缺点 每个组件都需要引入 比较多 繁琐 也容易忘导入
  - 全局导入：在vue项目入口(main.js) 添加一段配置 这样以后每个组件都无需导入axios

`main.js`

```js
import axios from 'axios'

const app = createApp(App)
//全局引入axios 这样定义好了后 其他组件就可以通过这个任意名称 发送异步请求
//就是在全局配置中添加了 axios别名
app.config.globalProperties.aaa=axios
app.mount('#app')
```

`vue组件中新版使用案例`

```vue
<template>
    <p>账号：<input v-model="user.account"></p>
    <p>密码：<input v-model="user.password"></p>
    <p>手机：<input v-model="user.phone"></p>
    <button @click="add">新增</button>
</template>

<script setup>
import {ref,getCurrentInstance} from "vue"
// 类似于老版本的this获取当前的实例 {proxy} 是固定返回的 要求不能改名字 需要加大括号
// 老版直接this.aaa.post ...
const {proxy} = getCurrentInstance()
const user=ref({})
let add = ()=>{
    proxy.aaa.post("http://localhost:8082/add",user.value).then(res=>{
        console.log(res.data);
    })
}
</script>
```

#### 8.3 请求的封装 ---重点

虽然使用了单次导入axios和全局导入axios 但是两种方式各有优缺点，全局导入缺点 没有对请求的安全做限制 而且 发送请求的时候也会有很多相同的部分

```
http://localhost:9999/add
http://localhost:9999/sel
http://localhost:9999	就属于相同的部分
```

- 创建一个包`src/util`	创建一个`request.js`(或者`http.js`) 

`request.js`

```js
//将axios对象进行封装 提高安全性
//1.导入axios
import axios from "axios";

//2.创建错误映射    status:状态码  info:错误信息
const errorHandler = (status,info)=>{
    switch(status){
        case 400:console.log("客户端参数有误");break;
        case 403:console.log("无访问权限");break;
        case 404:console.log("资源不存在/地址错误");break;
        case 500:console.log(info);break;
        default:console.log(info);
    }
}

//3.通过axios创建请求实例
const instance = axios.create({
    //控制超时时间 单位毫秒
    timeout:5000
})

//4.通过请求实例配置请求拦截器(成功的函数,失败的函数)
instance.interceptors.request.use(
    config=>{
        if(config.method == "post"){
            //处理所有的post请求 看公司要求
        }else if(config.method == "get"){
            //处理所有的get请求
        }
        //... 可以写很多个
        return config;
    },
    error=>{
        //返回错误信息
        return Promise.reject(error)
    }
)
//5.通过请求实例配置响应拦截器(响应成功的函数,响应失败的数据)
instance.interceptors.response.use(
    response=>{
        //根据状态码是否是200来控制是否返回正确或失败信息
        return response.status==200?Promise.resolve(response):Promise.reject(response)
    },
    error=>{
        //定义响应变量 常量 不能改
        const {response} = error
        //调用上面的错误映射传入状态码和错误信息
        errorHandler(response.status,response.info)
    }
)

//6.导出请求实例
export default instance;
```

- 创建一个包 api包（一般存放的是发送网络请求，文件可能会有很多），比如：base.js（可以处理通用地址)	index.js  user.js   bbs.js

`base.js`

```js
//创建公共地址的 比如：http://localhost:9999
//这样其他请求 公共部分无需编写了
const base = {
    baseUrl:"http://localhost:8082"
}
export default base;
```

`index.js`：这个文件不同的公司 名称可能不同 但是目的是一样的(调用之前封装好的请求 和 定义好的公共地址)

```js
//1.引入封装好的请求 当前文件和导入文件都是js 后缀js可以省略
import axios from '../util/request'
//2.引入封装好的公共地址
import base from './base'

//创建公共API接口 编写好了 以后发送不同模块网络请求都是引入这个api接口 来实现
//如果公司业务不同 这个也是经常修改的
const api = {
    //比如：post请求封装在一起
    postReq(url,data){
        return axios.post(base.baseUrl+url,data)
    },
    //比如：get请求封装在一起
    getReq(url,data){
        return axios.post(base.baseUrl+url,data)
    }
}

export default api;

//其他组件如何使用
// api.postReq('/add',data).then(res=>{})
```

- 如何使用封装好的api接口发送请求

```js
<template>
    <table>
        <tr>
            <td>编号</td>
            <td>账号</td>
            <td>密码</td>
            <td>姓名</td>
            <td>手机</td>
        </tr>
        <tr v-for="u in users">
            <th>{{ u.id }}</th>
            <th>{{ u.account }}</th>
            <th>{{ u.password }}</th>
            <th>{{ u.name }}</th>
            <th>{{ u.phone }}</th>
        </tr>
    </table>
</template>

<script setup>
import {ref, onMounted} from "vue"
import api from '../api/index'

const users = ref({})
//不需要我们触发 到了挂载生命周期 自动触发
onMounted(()=>{
    //由于没有参数传递 {} 占位置
    api.postReq('/show',{}).then(res=>{
        users.value = res.data.data.list
    })
})
</script>
```

## 9. 前端跨域

前端跨域一般可以通过前端vue项目的配置文件`vue.config.js` 添加一段配置 添加一个proxy代理对象 配置好后端地址 代理对象帮我们转发到目标地址

`vue.config.js`

```js
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  //将依赖进行转义，主要是用于增加代码在不同语言兼容性
  transpileDependencies: true,
  devServer:{
    //跨域代理对象
    proxy:{
      //可以配置很多组跨域 每组跨域都是一个对象
      // '/任意写':{配置好了跨域}
      // http://localhost:9999/任意写/show 就可以跨域了
      // /任意写/show 也可以跨域
      '/api':{//配置一个名为api的代理
        //配置后端地址 proxy会转发到这里去
        target:'http://localhost:8082',
        //路径重写 目的是去除请求地址中的/api
        pathRewrite:{"^/api":''},
        //代理webSockets 可以不配置
        ws:true,
        //开启跨域
        changeOrigin:true
      }
    }
  }
})
```

```
配置前：http://localhost:8082/show  -> 访问后端查询 但是会出现跨域问题
配置好后：/api/show -> http://localhost:8082/api/show
	再进行路径重写去除多余/api -> http://localhost:8082/show
```

如果请求封装了只需要修改`base.js`

```js
//创建公共地址的 比如：http://localhost:9999
//这样其他请求 公共部分无需编写了
const base = {
    // baseUrl:"http://localhost:8082"
    baseUrl:"/api"  //等价于http://localhost:8082
}
export default base;
```

==注：修改了vue.config.js 一定要重启服务器 否则不生效==

## 10. Vue路由 ---重点

路由主要用来管理vue组件中的关系 可以实现路径跳转 可以实现组件之间的传值，这样可以让vue.js 构建单页的应用更加轻松

#### 10.1 路由安装

- 通过vue ui界面安装

![70be1767ccd96b1c0acfaf866f6d4def](https://s2.loli.net/2024/08/26/wVf9BQq7cnpyRb2.png)

![fc49996fac20dd7f68857b851878a85e](https://s2.loli.net/2024/08/26/19lgKqrAmVbPsMc.png)

![1de49dcabc6468d4c254a24c1faa7db0](https://s2.loli.net/2024/08/26/LjfmHPz48VZwlKT.png)

- 通过创建vue项目选择route插件安装

==注：不要通过cnpm安装 语法都会通过 但是路由会失效，推荐使用vue ui图形界面方式安装依赖 ，或者创建vue项目的时候 选择路由插件==

#### 10.2 路由配置

创建一个包`src/router`用来保存路由配置文件(index.js) 通过路由管理所有vue组件，创建一个`src/views`包 用来保存所有被路由管理的vue组件 其他的vue组件依然可以保存在原来的components包

- views：创建组件的位置 比如：home.vue    user.vue
- router：创建一个index.js 编写路由规则(引入路由 路由规则 创建路由 导出路由)

```js
//1.导入路由组件对象
import { createRouter,createWebHashHistory } from "vue-router";
import home from '../views/home.vue'

//2.创建路由规则对象(数组 因为vue组件有很多个)
//routes 不能改
const routes = [
    {
        path:'/',    //访问的路径
        component:home
    },{
        path:'/user',
        //这种写法 属于异步加载 上面的方式属于同步加载
        //一般来说首页适合 同步加载 其他组件 都是异步加载
        component:()=>import('../views/user.vue')
    }
]

//3.创建路由组件
const router = createRouter({
    //配置路由历史模式,常用的两种历史模式（寻址方式）
    //createWebHashHistory：URL带#号，无需服务器支持，快速实现 比较常用 需要配合后端做重定向 否则会404
    //createWebHistory：更干净的URL，需服务器支持
    history:createWebHashHistory(),
    routes  //路由规则
})

//4.导出vue组件对象
export default router;
```

- mian.js：在vue项目的入口 启动vue 路由

```js
//引入路由 如果格式是js 可以省略后缀
//如果文件名就一个 叫index.js 都可以省略
import router from './router'

//使用路由 app创建之后 挂载之前 位置一定不能换
createApp(App).use(router).mount('#app')
```

#### 10.3 使用路由

在vue项目的首页(App.vue) 其他页面也可以添加 添加几个标签

```vue
<!--路由显示的入口-->
<router-view/>			<routerView/>

<!--等价于之前的a标签 链接标签-->
<router-link to="链接地址">链接名字</router-link>
```

#### 10.4 路由传参

类似于后端 根据id传递后端 会在同一个页面显示不同的内容，而vue路由肯定也需要这种需求

- 路由配置地址的时候添加`:`表示 传递参数

```js
{
    path:'/user/:id/:name',
    component:()=>import("../views/user.vue")
}
```

- router-link标签地址跳转时传入指定的数据(要根据配置的方式一样的)

```vue
<router-link to="/user/10/衣服">用户</router-link>
```

- 进入指定的组件后 获取id和name属性值

```vue
<template>
	{{ $route.params.id }}
	{{ $route.params.name }}
</template>
<script>
	import {useRoute} from 'vue-route'
    const id=useRoute().params.id
    const name=useRoute().params.name
</script>
```

#### 10.5 二级路由

如果项目中的功能特别复杂 会涉及到很多组件 肯定会出现父级导航 和子级导航，每个导航 都有很多子级组件 对应 就要涉及到二级路由或多级路由

- 路由配置文件添加属性`children`

```js
,{//一级路由
        path:'/article',
        component:()=>import('../views/article.vue'),
        //二级路由 二级路由开始 地址不要加/
        children:[
            {
                path:'history',
                component:()=>import('../views/article/history.vue')
            },
            {
                path:'music',
                component:()=>import('../views/article/music.vue')
            }
        ]
    }
```

- 在一级路由组件页面中 通过`<routrr-link to="/一级/二级">`

```vue
<RouterLink to="/article/sports">体育栏目</RouterLink>
<div>
    <RouterView/>
</div>
```

==注：如果是三级路由，继续无限嵌套 理论上是没有上限的==

## 11. Elementplus

Elementplus应用场景非常广泛 比如：pc端 移动端 微信小程序 通常用于实现他们后台管理界面 提供很多编写好的可视化UI组件 如果环境搭建好了只需要Elementplus官网代码复制过来即可生效 是基于Vue3.0以上的版本 如果是Vue2.0版本兼容的是ElementUI

[官网](https://element-plus.org/zh-CN/)

#### 11.1 安装

通过Vue ui图形化界面安装依赖 参考路由的导入方式 搜索`elementplus`安装

![63516bdbe31c2ee10431a896b7b07028](https://s2.loli.net/2024/08/27/TPHIt1bVJZQpYMo.png)

==注：不推荐使用命令安装 因为会失效 原因在于elementplus内部有一个utils包也引入了vue 和安装的vue版本会有冲突==

#### 11.2 引入

- 完整引入：无论是否需要 不用在乎打包的项目大小 优点在于使用更方便

`main.js 以后main.ts`

```js
//1.导入elementplus
import Elementplus from 'element-plus'
import 'element-plus/dist/index.css'

//2.使用elementplus  如果导入了路由需要在路由之前使用 否者失效
createApp(App).use(Elementplus).use(router).mount('#app')
```

- 按需引入：应用场景比较广泛 会根据需要引入必要组件 比较节省空间 缺点在于需要做额外配置

  - 安装两个必要的插件 `components`和`auto-import`
    bug：插件的版本需要回退老版本 新版本不兼容

  ```
  cnpm install -D unplugin-vue-components@0.25.2 unplugin-auto-import@0.16.1
  ```

  - 修改`vue.config.js`配置文件 查看官网修改

  ```js
  const { defineConfig } = require('@vue/cli-service')
  // 按需引用添加的内容
  const AutoImport = require('unplugin-auto-import/webpack')
  const Components = require('unplugin-vue-components/webpack')
  const { ElementPlusResolver } = require('unplugin-vue-components/resolvers')
  module.exports = defineConfig({
    transpileDependencies: true,
    //需要加一个关键字
    configureWebpack:{
      //官网复制粘贴来的
      plugins: [
        AutoImport({
          resolvers: [ElementPlusResolver()],
        }),
        Components({
          resolvers: [ElementPlusResolver()],
        }),
      ]
    }
  })
  ```

  - main.js 还原 之前的全局引入删除

#### 11.3 使用

无论是按需引入还是全局引入 使用方式基本都是一样 只需要在elementplus组件官网找到需要的组件 查看源代码 复制到自己的vue组件中 刷新即可使用

#### 11.4 TypeScript

很多elementplus组件都要用到ts语法，所以创建项目要支持ts语法，配置路由和axios 配置文件时使用.ts文件，修改一下ts的语法

方法参数都需要添加类型，添加格式(参数1:类型,参数2:类型)
 ts语法 如果参数后面添加?表示可选参数

## 12. Vant
